if getgenv().wanderkiddfakepos_loaded then
    return
end
getgenv().wanderkiddfakepos_loaded = true

local api = getfenv().api or {}

local tabs = getgenv().wanderkidd_tabs or {
    lua = api:AddTab('$SUDOAPI'),
}
getgenv().wanderkidd_tabs = tabs

local networkSection = tabs.lua:AddLeftGroupbox('Shadow-Clone Jutsu')

local logsSection = tabs.lua:AddRightGroupbox('Info')
logsSection:AddLabel(
    'Note: Fake Pos will only work on the normal version of Unamed Enhancements and not the beta version.',
    true
)


getgenv().wanderkiddfakepos = getgenv().wanderkiddfakepos or {}
local wanderkiddfakepos = getgenv().wanderkiddfakepos

wanderkiddfakepos.Network = wanderkiddfakepos.Network
    or {
        FakePos = false,
    }

local framework = {}
framework.keybindPressed = false

if not wanderkiddfakepos._connection then
    wanderkiddfakepos._connection = game:GetService('RunService').Heartbeat
        :Connect(function()
            if wanderkiddfakepos.Network.FakePos then
                pcall(function()
                    local character = game.Players.LocalPlayer.Character
                    if character and character:FindFirstChild('HumanoidRootPart') then
                        -- NEW METHOD: Toggle NetworkIsSleeping to appear frozen, not laggy
                        local hrp = character.HumanoidRootPart
                        
                        -- Toggle between true/false to create frozen effect instead of laggy
                        if wanderkiddfakepos._toggleState then
                            sethiddenproperty(hrp, 'NetworkIsSleeping', true)
                        else
                            sethiddenproperty(hrp, 'NetworkIsSleeping', false)
                        end
                        wanderkiddfakepos._toggleState = not wanderkiddfakepos._toggleState
                    end
                end)
            end
        end)
end

if not wanderkiddfakepos._toggleCreated then
    local fakeposToggle = networkSection:AddToggle('fakepos_enabled', {
        Text = 'Fake Pos',
        Default = wanderkiddfakepos.Network.FakePos,
        Callback = function(value)
            wanderkiddfakepos.Network.FakePos = value
            if value then
                -- NEW METHOD: Initialize toggle state for frozen effect
                wanderkiddfakepos._toggleState = true
                setfflag('S2PhysicsSenderRate', '1')
                setfpscap(1)
                task.wait(0.1)
                setfflag('S2PhysicsSenderRate', '20000')
                setfpscap(240)
            else
                -- Disable fake pos
                setfflag('S2PhysicsSenderRate', '20000')
                setfpscap(240)
                wanderkiddfakepos._toggleState = nil
                pcall(function()
                    local character = game.Players.LocalPlayer.Character
                    if character and character:FindFirstChild('HumanoidRootPart') then
                        sethiddenproperty(character.HumanoidRootPart, 'NetworkIsSleeping', false)
                    end
                end)
            end
        end,
    })

    networkSection:AddDivider()
    
    networkSection:AddLabel('Toggle Key'):AddKeyPicker('fakepos_keybind', {
        Default = 'F',
        Mode = 'Toggle',
        Text = 'Fake Pos [Shadow-Clone Jutsu]',
        NoUI = false,
        Callback = function()
            if framework.keybindPressed then
                return
            end
            framework.keybindPressed = true
            fakeposToggle:SetValue(not fakeposToggle.Value)
            task.delay(0.2, function()
                framework.keybindPressed = false
            end)
        end,
    })

    wanderkiddfakepos._toggleCreated = true
end

-- Create TabBox for Misc and Farm sections
local TabBox = tabs.lua:AddRightTabbox() -- Add Tabbox on right side

-- Anything we can do in a Groupbox, we can do in a Tabbox tab (AddToggle, AddSlider, AddLabel, etc etc...)
local Tab1 = TabBox:AddTab('Misc')
local Tab2 = TabBox:AddTab('Farm')

getgenv().AntiRPGDesyncEnabled = false
getgenv().AntiRPGDesyncLoop = nil

local RunService = game:GetService('RunService')
local Workspace = game:GetService('Workspace')
local LocalPlayer = game.Players.LocalPlayer
local ReplicatedStorage = game:GetService('ReplicatedStorage')

local function IsThreatNear()
    local Ignored = Workspace:FindFirstChild('Ignored')
    if not Ignored then
        return false
    end
    local HRP = LocalPlayer.Character
        and LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
    if not HRP then
        return false
    end
    local RPG = Ignored:FindFirstChild('Model')
        and Ignored.Model:FindFirstChild('Launcher')
    local Grenade = Ignored:FindFirstChild('Handle')
    local grenadeNear = Grenade
        and (Grenade.Position - HRP.Position).Magnitude < 16
    return RPG or grenadeNear
end

local function StartThreatDetection()
    if getgenv().AntiRPGDesyncLoop then
        return
    end
    getgenv().AntiRPGDesyncLoop = RunService.PostSimulation:Connect(function()
        if not getgenv().AntiRPGDesyncEnabled then
            return
        end
        local Character = LocalPlayer.Character
        local HRP = Character and Character:FindFirstChild('HumanoidRootPart')
        local Humanoid = Character and Character:FindFirstChild('Humanoid')
        if not HRP or not Humanoid then
            return
        end
        if IsThreatNear() then
            local Offset = Vector3.new(
                math.random(-100, 100),
                math.random(50, 150),
                math.random(-100, 100)
            )
            Humanoid.CameraOffset = -Offset
            local OldCFrame = HRP.CFrame
            HRP.CFrame = CFrame.new(HRP.Position + Offset)
            RunService.RenderStepped:Wait()
            HRP.CFrame = OldCFrame
        end
    end)
    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        if getgenv().AntiRPGDesyncEnabled then
            StartThreatDetection()
        end
    end)
end

local function StopThreatDetection()
    if getgenv().AntiRPGDesyncLoop then
        getgenv().AntiRPGDesyncLoop:Disconnect()
        getgenv().AntiRPGDesyncLoop = nil
    end
end

-- Add RPG + Grenade Detection Toggle
Tab1:AddToggle('CombinedThreatDetection', {
    Text = 'RPG + Grenade Detection',
    Default = false,
    Callback = function(state)
        getgenv().AntiRPGDesyncEnabled = state
        if state then
            StartThreatDetection()
        else
            StopThreatDetection()
        end
    end,
})

local CASH_AURA_ENABLED = false
local COOLDOWN = 0.2
local CASH_AURA_RANGE = 17

local function GetCash()
    local Found = {}
    local Drop = workspace:FindFirstChild('Ignored')
        and workspace.Ignored:FindFirstChild('Drop')

    if Drop then
        for _, v in pairs(Drop:GetChildren()) do
            if v.Name == 'MoneyDrop' then
                local Pos = v:GetAttribute('OriginalPos') or v.Position

                if
                    game.Players.LocalPlayer.Character
                    and game.Players.LocalPlayer.Character:FindFirstChild(
                        'HumanoidRootPart'
                    )
                    and (
                            Pos
                            - game.Players.LocalPlayer.Character.HumanoidRootPart.Position
                        ).Magnitude
                        <= CASH_AURA_RANGE
                then
                    table.insert(Found, v)
                end
            end
        end
    end

    return Found
end

local function CashAura()
    while CASH_AURA_ENABLED do
        local Cash = GetCash()

        for _, v in pairs(Cash) do
            local clickDetector = v:FindFirstChildOfClass('ClickDetector')
            if clickDetector then
                pcall(function()
                    fireclickdetector(clickDetector)
                end)
            end
        end

        task.wait(COOLDOWN)
    end
end

Tab1:AddToggle('Cash_Aura_Toggle', {
    Text = 'Cash Aura',
    Default = false,
    Callback = function(Value)
        CASH_AURA_ENABLED = Value
        if CASH_AURA_ENABLED then
            task.spawn(CashAura)
        end
    end,
})

Tab1:AddToggle('AutoBlockToggle', {
    Text = 'Auto Block',
    Default = false,
    Callback = function(state)
        getgenv().autoBlockEnabled = state

        if getgenv().autoBlockConnection then
            getgenv().autoBlockConnection:Disconnect()
            getgenv().autoBlockConnection = nil
        end

        if state then
            getgenv().autoBlockConnection = game:GetService('RunService').Heartbeat
                :Connect(function()
                    local char = game.Players.LocalPlayer.Character
                    if not char then
                        return
                    end

                    -- Fire block request
                    game.ReplicatedStorage.MainEvent:FireServer('Block', true)

                    -- Stop specific animation
                    local hum = char:FindFirstChildOfClass('Humanoid')
                    if hum then
                        for _, anim in ipairs(hum:GetPlayingAnimationTracks()) do
                            if
                                anim.Animation.AnimationId:match('2788354405')
                            then
                                anim:Stop()
                            end
                        end
                    end

                    -- Remove block status effect
                    local effects = char:FindFirstChild('BodyEffects')
                    if effects and effects:FindFirstChild('Block') then
                        effects.Block:Destroy()
                    end
                end)
        end
    end,
})

Tab1:AddToggle('AntiSitToggle', {
    Text = 'Anti Sit',
    Default = false,
    Callback = function(state)
        getgenv().antiSitEnabled = state
        for _, seat in ipairs(workspace:GetDescendants()) do
            if seat:IsA('Seat') or seat:IsA('VehicleSeat') then
                seat.CanTouch = not state
            end
        end
        workspace.DescendantAdded:Connect(function(seat)
            if
                getgenv().antiSitEnabled
                and (seat:IsA('Seat') or seat:IsA('VehicleSeat'))
            then
                seat.CanTouch = false
            end
        end)
    end,
})

Tab1:AddToggle('AntiFlingToggle', {
    Text = 'Anti Fling',
    Default = false,
    Callback = function(state)
        local rs = game:GetService("RunService")
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        
        if state then
            -- Disconnect existing connection if any
            if _G.fling then 
                _G.fling:Disconnect() 
                _G.fling = nil
            end
            
            local function startAntiFling()
                local character = LocalPlayer.Character
                if not character then return end
                
                local hrp = character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end
                
                local last = hrp.Position
                print("Anti-Fling enabled")
                
                _G.fling = rs.Heartbeat:Connect(function()
                    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        return
                    end
                    
                    local currentHrp = LocalPlayer.Character.HumanoidRootPart
                    local distance = (currentHrp.Position - last).Magnitude
                    
                    -- Ultra-sensitive detection (1 stud) to catch punching scripts
                    if distance > 1 then
                        print("Anti-Fling: Detected fling from punching script, teleporting back")
                        
                        -- Immediate and aggressive protection
                        currentHrp.CFrame = CFrame.new(last)
                        currentHrp.Velocity = Vector3.zero
                        currentHrp.AssemblyLinearVelocity = Vector3.zero
                        currentHrp.AssemblyAngularVelocity = Vector3.zero
                        
                        -- Destroy ALL body movers and constraints
                        for _, obj in pairs(currentHrp:GetChildren()) do
                            if obj:IsA("BodyVelocity") or obj:IsA("BodyAngularVelocity") or obj:IsA("BodyPosition") or obj:IsA("BodyThrust") or obj:IsA("BodyMover") then
                                obj:Destroy()
                            end
                        end
                        
                        -- Also check and destroy body movers in character
                        for _, obj in pairs(LocalPlayer.Character:GetChildren()) do
                            if obj:IsA("BodyVelocity") or obj:IsA("BodyAngularVelocity") or obj:IsA("BodyPosition") or obj:IsA("BodyThrust") or obj:IsA("BodyMover") then
                                obj:Destroy()
                            end
                        end
                        
                        -- Ultra-aggressive position forcing
                        task.spawn(function()
                            for i = 1, 10 do
                                task.wait(0.01) -- Much faster correction
                                if currentHrp then
                                    currentHrp.CFrame = CFrame.new(last)
                                    currentHrp.Velocity = Vector3.zero
                                    currentHrp.AssemblyLinearVelocity = Vector3.zero
                                    currentHrp.AssemblyAngularVelocity = Vector3.zero
                                end
                            end
                        end)
                        
                        -- Additional protection - freeze character briefly
                        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                        if humanoid then
                            humanoid.PlatformStand = true
                            task.wait(0.1)
                            humanoid.PlatformStand = false
                        end
                    else
                        last = currentHrp.Position
                    end
                end)
            end
            
            -- Start immediately if character exists
            startAntiFling()
            
            -- Also start when character respawns
            _G.characterAddedConnection = LocalPlayer.CharacterAdded:Connect(function()
                task.wait(1) -- Wait for character to fully load
                startAntiFling()
            end)
            
        else
            -- Disable anti-fling
            if _G.fling then 
                _G.fling:Disconnect() 
                _G.fling = nil
            end
            if _G.characterAddedConnection then
                _G.characterAddedConnection:Disconnect()
                _G.characterAddedConnection = nil
            end
            print("Anti-Fling disabled")
        end
    end,
})

-- Farm section is now Tab2


-- Your existing services and variables
local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local TweenService = game:GetService('TweenService')
local LocalPlayer = Players.LocalPlayer

local cashierFolder = workspace:FindFirstChild('Cashiers')
local dropFolder = workspace:FindFirstChild('Ignored')
    and workspace.Ignored:FindFirstChild('Drop')
local attackRadius = 15

local farming = false
local currentCharacter = LocalPlayer.Character
    or LocalPlayer.CharacterAdded:Wait()
local healthConnection = nil
local attackThread = nil
local farmingThread = nil
local noclipConnection = nil
local antiAFKConnection = nil
local antiSitConnection = nil

LocalPlayer.CharacterAdded:Connect(function(char)
    currentCharacter = char
    if farming then
        task.wait(5)
        startFarming()
        monitorHealth(true)
    end
end)

function monitorHealth(enable)
    local humanoid = currentCharacter:WaitForChild('Humanoid', 5)
    if not humanoid then
        return
    end

    if healthConnection then
        healthConnection:Disconnect()
        healthConnection = nil
    end

    if enable then
        healthConnection = humanoid.HealthChanged:Connect(function(newHealth)
            if newHealth < 3 then
                if currentCharacter then
                    currentCharacter:BreakJoints()
                end
                if humanoid and humanoid.Health > 0 then
                    humanoid.Health = 0
                end
                task.delay(0.5, function()
                    if humanoid and humanoid.Health > 0 then
                        humanoid:Destroy()
                    end
                end)
            end
        end)
    end
end

local function equipCombat()
    if not currentCharacter then
        return
    end
    local backpack = LocalPlayer:FindFirstChild('Backpack')
    if not backpack then
        return
    end

    local tool = currentCharacter:FindFirstChild('Combat')
        or backpack:FindFirstChild('Combat')
    if not tool then
        return
    end
    if currentCharacter:FindFirstChild('Combat') == nil then
        LocalPlayer.Character.Humanoid:EquipTool(tool)
    end
end

local function autoAttack()
    if attackThread then
        return
    end
    attackThread = task.spawn(function()
        while
            farming
            and currentCharacter
            and currentCharacter:FindFirstChild('Humanoid')
        do
            local combatTool = currentCharacter:FindFirstChild('Combat')
            if combatTool then
                combatTool:Activate()
            else
                equipCombat()
            end
            task.wait(1)
        end
        attackThread = nil
    end)
end

local function setNoClip(enabled)
    if enabled then
        noclipConnection = RunService.Stepped:Connect(function()
            if currentCharacter then
                for _, part in pairs(currentCharacter:GetChildren()) do
                    if part:IsA('BasePart') then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
        if currentCharacter then
            for _, part in pairs(currentCharacter:GetChildren()) do
                if part:IsA('BasePart') then
                    part.CanCollide = true
                end
            end
        end
    end
end

local function startAntiAFK()
    if antiAFKConnection then
        antiAFKConnection:Disconnect()
        antiAFKConnection = nil
    end
    
    antiAFKConnection = RunService.Heartbeat:Connect(function()
        if not farming then
            return
        end
        
        local character = LocalPlayer.Character
        if character and character:FindFirstChild('Humanoid') then
            local humanoid = character.Humanoid
            -- Move slightly to prevent AFK detection
            humanoid:Move(Vector3.new(math.random(-1, 1), 0, math.random(-1, 1)))
        end
    end)
end

local function startAntiSit()
    if antiSitConnection then
        antiSitConnection:Disconnect()
        antiSitConnection = nil
    end
    
    -- Disable all existing seats
    for _, seat in ipairs(workspace:GetDescendants()) do
        if seat:IsA('Seat') or seat:IsA('VehicleSeat') then
            seat.CanTouch = false
        end
    end
    
    -- Connect to new seats
    antiSitConnection = workspace.DescendantAdded:Connect(function(seat)
        if farming and (seat:IsA('Seat') or seat:IsA('VehicleSeat')) then
            seat.CanTouch = false
        end
    end)
end

local function stopAntiAFK()
    if antiAFKConnection then
        antiAFKConnection:Disconnect()
        antiAFKConnection = nil
    end
end

local function stopAntiSit()
    if antiSitConnection then
        antiSitConnection:Disconnect()
        antiSitConnection = nil
    end
    
    -- Re-enable all seats
    for _, seat in ipairs(workspace:GetDescendants()) do
        if seat:IsA('Seat') or seat:IsA('VehicleSeat') then
            seat.CanTouch = true
        end
    end
end

local function tweenToPosition(position, duration)
    if
        currentCharacter
        and currentCharacter:FindFirstChild('HumanoidRootPart')
    then
        local hrp = currentCharacter.HumanoidRootPart
        local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear)
        local tween = TweenService:Create(
            hrp,
            tweenInfo,
            { CFrame = CFrame.new(position) }
        )
        tween:Play()
        tween.Completed:Wait()
    end
end

local function tpInsideModelTween(model)
    local rootPart = model.PrimaryPart
        or model:FindFirstChildWhichIsA('BasePart', true)
    if not rootPart then
        return
    end
    local targetPos = rootPart.Position
    tweenToPosition(targetPos, 0.4)
end

local function collectDrops()
    if
        not dropFolder
        or not currentCharacter
        or not currentCharacter:FindFirstChild('HumanoidRootPart')
    then
        return
    end
    
    local hrp = currentCharacter.HumanoidRootPart
    local hrpPos = hrp.Position
    
    for _, drop in ipairs(dropFolder:GetChildren()) do
        if drop:IsA('BasePart') then
            local dist = (drop.Position - hrpPos).Magnitude
            if dist <= attackRadius then
                local clickDetector = drop:FindFirstChildWhichIsA('ClickDetector', true)
                if clickDetector then
                    fireclickdetector(clickDetector)
                    task.wait(0.5) -- Slower pickup wait
                end
            end
        end
    end
end

function startFarming()
    if farmingThread then
        return
    end
    
    -- Start anti-AFK and anti-sit
    startAntiAFK()
    startAntiSit()
    
    farmingThread = task.spawn(function()
        setNoClip(true)
        while farming do
            if not cashierFolder then
                break
            end
            local cashiers = cashierFolder:GetChildren()
            for i = 1, #cashiers do
                if not farming then
                    break
                end
                local cashier = cashiers[i]
                if cashier.Name == 'CA$HIER' then
                    local humanoid =
                        cashier:FindFirstChildWhichIsA('Humanoid', true)
                    if humanoid and humanoid.Health > 0 then
                        if not cashier.PrimaryPart then
                            local firstPart =
                                cashier:FindFirstChildWhichIsA('BasePart', true)
                            if firstPart then
                                cashier.PrimaryPart = firstPart
                            else
                                continue
                            end
                        end

                        equipCombat()
                        tpInsideModelTween(cashier)
                        autoAttack()
                        
                        -- Punch counting for ATM switching
                        local punchCount = 0
                        local maxPunches = 10 -- Switch if ATM doesn't open after 10 hits
                        local originalHealth = humanoid.Health
                        local atmDefeated = false
                        
                        while farming and humanoid.Health > 0 do
                            collectDrops()
                            tpInsideModelTween(cashier)
                            
                            -- Check if health hasn't decreased (ATM not opening)
                            if humanoid.Health >= originalHealth then
                                punchCount = punchCount + 1
                                if punchCount > maxPunches then
                                    -- ATM not opening after 10+ hits, switch immediately
                                    break
                                end
                            else
                                -- Health decreased, ATM is being damaged
                                punchCount = 0
                                originalHealth = humanoid.Health
                            end
                        end
                        
                        -- Check if ATM was defeated (health reached 0)
                        if humanoid.Health <= 0 then
                            atmDefeated = true
                        end
                        
                        -- Always wait for cash collection after ATM interaction
                        if atmDefeated then
                            local dropsRemain = true
                            local collectionAttempts = 0
                            local maxCollectionAttempts = 50 -- Prevent infinite loop
                            
                            while farming and dropsRemain and collectionAttempts < maxCollectionAttempts do
                                dropsRemain = false
                                collectionAttempts = collectionAttempts + 1
                                
                                if
                                    dropFolder
                                    and currentCharacter
                                    and currentCharacter:FindFirstChild(
                                        'HumanoidRootPart'
                                    )
                                then
                                    local hrp = currentCharacter.HumanoidRootPart
                                    local hrpPos = hrp.Position
                                    
                                    for _, drop in ipairs(dropFolder:GetChildren()) do
                                        if drop:IsA('BasePart') then
                                            local dist = (drop.Position - hrpPos).Magnitude
                                            if dist <= attackRadius then
                                                dropsRemain = true
                                                break
                                            end
                                        end
                                    end
                                end
                                
                                if dropsRemain then
                                    collectDrops()
                                    tpInsideModelTween(cashier)
                                    task.wait(0.3) -- Slower drop collection cycle
                                end
                            end
                        end

                        task.wait(1)
                    end
                end
            end
            task.wait(1)
        end
        setNoClip(false)
        farmingThread = nil
        attackThread = nil
    end)
end

function stopFarming()
    farming = false
    farmingThread = nil
    attackThread = nil
    setNoClip(false)
    
    -- Stop anti-AFK and anti-sit
    stopAntiAFK()
    stopAntiSit()
end


-- UI Toggles
-- Add ATM Farm toggle on top
Tab2:AddToggle('cashatmfarm', {
    Text = 'ATM Farm',
    Default = false,
    Callback = function(Value)
        -- Disable Stomp Farm when ATM Farm enabled
        Toggles.AutoStompFarm:SetValue(false)

        if Value then
            farming = true
            monitorHealth(true)
            startFarming()
        else
            stopFarming()
            monitorHealth(false)
        end
    end,
})

local Players = game:GetService('Players')
local Workspace = game:GetService('Workspace')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local RunService = game:GetService('RunService')

local LocalPlayer = Players.LocalPlayer
local Backpack = LocalPlayer:WaitForChild('Backpack')

local AutoStompPos = CFrame.new(-1123, 21.75, -217.5)
local Event = ReplicatedStorage:WaitForChild('MainEvent')

local farmEnabled = false
local stompTask
local originalStompPosition = nil

local function Teleport(pos)
    local char = LocalPlayer.Character
    if char and char:FindFirstChild('HumanoidRootPart') then
        char.HumanoidRootPart.CFrame = pos
    end
end

local function GetPlayerPositionForTeleport(character)
    local root = character:FindFirstChild('HumanoidRootPart')
    if not root then
        return nil
    end
    local parts = {}
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA('BasePart') then
            table.insert(parts, part.Position)
        end
    end
    if #parts == 0 then
        return root.CFrame + Vector3.new(0, 3, 0)
    end
    local sum = Vector3.new(0, 0, 0)
    for _, pos in ipairs(parts) do
        sum = sum + pos
    end
    local avgPos = sum / #parts
    return CFrame.new(avgPos + Vector3.new(0, 3, 0))
end

local function GetValidTargets()
    local targets = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local humanoid = player.Character:FindFirstChildOfClass('Humanoid')
            local root = player.Character:FindFirstChild('HumanoidRootPart')
            if
                humanoid
                and root
                and humanoid.Health <= 2
                and humanoid.Health > 0
            then
                table.insert(targets, root)
            end
        end
    end
    return targets
end

local function StartStompFarm()
    stompTask = task.spawn(function()
        while farmEnabled do
            local targets = GetValidTargets()
            for _, targetRoot in pairs(targets) do
                if not farmEnabled then
                    break
                end
                local teleportPos =
                    GetPlayerPositionForTeleport(targetRoot.Parent)
                if teleportPos then
                    Teleport(teleportPos)
                else
                    Teleport(targetRoot.CFrame + Vector3.new(0, 3, 0))
                end
                task.wait(0.2)
                Event:FireServer('Stomp')
                task.wait(0.1)
                Teleport(AutoStompPos)
                task.wait(0.2)
            end
            task.wait(0.5)
        end
    end)
end

local function StopStompFarm()
    farmEnabled = false
    if stompTask then
        task.cancel(stompTask)
        stompTask = nil
    end
    
    -- Teleport back to original position when disabled
    if originalStompPosition then
        Teleport(originalStompPosition)
        originalStompPosition = nil
    end
end

local function OnCharacterAdded(char)
    char:WaitForChild('HumanoidRootPart')
    if farmEnabled then
        Teleport(AutoStompPos)
    end
end

LocalPlayer.CharacterAdded:Connect(OnCharacterAdded)

Tab2:AddToggle('AutoStompFarm', {
    Text = 'Stomp Farm',
    Default = false,
    Callback = function(Value)
        farmEnabled = Value
        if farmEnabled then
            -- Save original position when enabling
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
                originalStompPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
            end
            
            if
                not (
                    LocalPlayer.Character
                    and LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
                )
            then
                LocalPlayer.CharacterAdded:Wait()
                -- Save position after character loads
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
                    originalStompPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
                end
            end
            Teleport(AutoStompPos)
            StartStompFarm()
        else
            StopStompFarm()
        end
    end,
})

do
    local Players = game:GetService('Players')
    local RunService = game:GetService('RunService')
    local player = Players.LocalPlayer
    local targetPos = Vector3.new(-279.602, 22.568, -1142.230)
    local toolName = 'Combat'
    local toggleEnabled = false
    local heartbeatConn
    local charAddedConn
    local activateLoopRunning = false
    local activateLoopCancel = false
    local originalPos = nil
    local targetPart =
        workspace.MAP.Map['Punching(BAGS)']:GetChildren()[3]['pretty ransom']

    local function equipTool(character)
        if not character then
            return nil
        end
        local backpack = player:WaitForChild('Backpack')
        local humanoid = character:FindFirstChildOfClass('Humanoid')
        if not humanoid then
            return nil
        end
        local tool = backpack:FindFirstChild(toolName)
            or character:FindFirstChild(toolName)
        if tool then
            if character:FindFirstChild(toolName) ~= tool then
                humanoid:EquipTool(tool)
                task.wait(0.01) -- Super fast equip wait
            end
            return tool
        end
        return nil
    end

    local function unequipTools(character)
        if not character then
            return
        end
        local humanoid = character:FindFirstChildOfClass('Humanoid')
        if humanoid then
            humanoid:UnequipTools()
        end
    end

    local function teleportAndFacePart(character, part)
        local hrp = character:FindFirstChild('HumanoidRootPart')
        if hrp and part then
            -- Teleport on top of the punching bag standing up straight
            local bagPosition = part.Position
            hrp.CFrame = CFrame.new(bagPosition + Vector3.new(0, 2, 0), bagPosition + Vector3.new(0, 0, 1))
        end
    end

    local function activateToolLoop(tool)
        activateLoopRunning = true
        activateLoopCancel = false
        local humanoid = player.Character
            and player.Character:FindFirstChildOfClass('Humanoid')
        while
            toggleEnabled
            and tool
            and tool.Parent
            and not activateLoopCancel
            and humanoid
        do
            if
                player.Character
                and player.Character:FindFirstChild(toolName) ~= tool
            then
                humanoid:EquipTool(tool)
                task.wait(0.01) -- Super fast equip wait
            end
            if tool.Activate then
                tool:Activate()
            end
            task.wait(0.01) -- Super fast activation wait
            humanoid:UnequipTools()
            task.wait(0.01) -- Super fast unequip wait
            humanoid:EquipTool(tool)
            task.wait(0.01) -- Super fast re-equip wait
        end
        activateLoopRunning = false
    end

    local function stopAll()
        toggleEnabled = false
        activateLoopCancel = true
        if heartbeatConn then
            heartbeatConn:Disconnect()
            heartbeatConn = nil
        end
        if charAddedConn then
            charAddedConn:Disconnect()
            charAddedConn = nil
        end
        local character = player.Character
        if character and character.Parent then
            local hrp = character:FindFirstChild('HumanoidRootPart')
            if hrp and originalPos then
                hrp.CFrame = originalPos
            end
            unequipTools(character)
        end
        originalPos = nil
    end

    local function onToggleChanged(value)
        if value == toggleEnabled then
            return
        end
        toggleEnabled = value
        if not toggleEnabled then
            stopAll()
            return
        end
        local character = player.Character
        if character and character.Parent then
            local hrp = character:FindFirstChild('HumanoidRootPart')
            if hrp then
                originalPos = hrp.CFrame
            end
        end
        activateLoopCancel = false
        heartbeatConn = RunService.Heartbeat:Connect(function()
            if not toggleEnabled then
                return
            end
            local character = player.Character
            if not character or not character.Parent then
                return
            end
            teleportAndFacePart(character, targetPart)
            local tool = equipTool(character)
            local humanoid = character:FindFirstChildOfClass('Humanoid')
            if humanoid and humanoid.Health < 2 then
                humanoid.Health = 0
            end
            if tool and not activateLoopRunning then
                task.spawn(function()
                    activateToolLoop(tool)
                end)
            end
        end)
        charAddedConn = player.CharacterAdded:Connect(function(char)
            if toggleEnabled then
                task.wait(0.01) -- Super fast respawn wait
                teleportAndFacePart(char, targetPart)
                equipTool(char)
            end
        end)
    end

    Tab2:AddToggle('BoxingFarm', {
        Text = 'Boxing Farm',
        Default = false,
        Callback = function(value)
            onToggleChanged(value)
        end,
    })
end

-- Lettuce position memory
local originalLettucePosition = nil

Tab2:AddToggle('lettuceToggle', {
    Text = 'Auto Lettuce',
    Default = false,
    Callback = function(value)
        if value then
            -- Save original position when enabling
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
                originalLettucePosition = LocalPlayer.Character.HumanoidRootPart.CFrame
            end
        else
            -- Teleport back to original position when disabled
            if originalLettucePosition then
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
                    LocalPlayer.Character.HumanoidRootPart.CFrame = originalLettucePosition
                end
                originalLettucePosition = nil
            end
        end
    end,
})

local function fireClickDetector(cd)
    if cd and cd:IsA('ClickDetector') then
        fireclickdetector(cd)
    end
end

local function equipLettuce()
    local tool = LocalPlayer.Backpack:FindFirstChild('[Lettuce]')
    if tool then
        tool.Parent = LocalPlayer.Character
        return tool
    end
    return nil
end

local function activateLettuce()
    local tool = LocalPlayer.Character
        and LocalPlayer.Character:FindFirstChild('[Lettuce]')
    if tool and tool:IsA('Tool') then
        tool:Activate()
        return true
    end
    return false
end

local function buyLettuce()
    LocalPlayer.Character:PivotTo(CFrame.new(-86.74, 23.32, -632.27))
    task.wait(0.05) -- Super fast teleport wait
    local shop = Workspace:FindFirstChild('Ignored')
        and Workspace.Ignored:FindFirstChild('Shop')
    if shop then
        for _, obj in ipairs(shop:GetDescendants()) do
            if
                obj:IsA('ClickDetector')
                and obj.Parent
                and obj.Parent.Name == '[Lettuce] - $5'
            then
                fireClickDetector(obj)
                break
            end
        end
    end
    task.wait(0.1) -- Super fast buy wait
end

task.spawn(function()
    while true do
        if Toggles.lettuceToggle.Value then
            -- Check if lettuce is equipped
            local hasLettuce = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('[Lettuce]')
            
            if not hasLettuce then
                -- No lettuce equipped, buy new one
                buyLettuce()
                equipLettuce()
            end
            
            -- Try to activate lettuce
            local activated = activateLettuce()
            
            -- If activation failed (lettuce was eaten), buy new one
            if not activated then
                task.wait(0.05)
                buyLettuce()
                equipLettuce()
            end
        end
        task.wait(0.05) -- Super fast cycle time
    end
end)

local toggleName = 'HeavyWeightsAuto'

Tab2:AddToggle(toggleName, {
    Text = 'Auto Weights',
    Default = false,
})

local activationConnection
local respawnConnection
local toolMonitorConnection
local originalWeightPosition = nil

local function getCharacter()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = char:WaitForChild('HumanoidRootPart')
    return char, hrp
end

local function teleportTo(pos)
    local _, hrp = getCharacter()
    hrp.CFrame = CFrame.new(pos)
    task.wait(0.5)
end

local function findShopItem()
    local shopFolder = Workspace.Ignored.Shop
    for _, item in ipairs(shopFolder:GetChildren()) do
        if item.Name:lower():find('heavyweights') then
            return item
        end
    end
    return nil
end

local function fireClickDetector(shopItem)
    if not shopItem then
        return
    end
    local clickDetector = nil
    if shopItem:IsA('ClickDetector') then
        clickDetector = shopItem
    else
        clickDetector = shopItem:FindFirstChild('ClickDetector')
            or shopItem:FindFirstChildWhichIsA('ClickDetector', true)
    end
    if clickDetector and clickDetector:IsA('ClickDetector') then
        pcall(function()
            fireclickdetector(clickDetector)
        end)
    end
end

local function equipTool(toolName)
    -- First check if already equipped
    local character = LocalPlayer.Character
    if character then
        local equippedTool = character:FindFirstChild(toolName)
        if equippedTool and equippedTool:IsA('Tool') then
            return equippedTool
        end
    end
    
    -- Try to find and equip from backpack
    for i = 1, 50 do -- Reduced iterations for faster response
        local tool = Backpack:FindFirstChild(toolName)
        if tool and tool:IsA('Tool') then
            local humanoid = character and character:FindFirstChild('Humanoid')
            if humanoid then
                humanoid:EquipTool(tool)
                task.wait(0.1) -- Short wait to ensure tool is equipped
                return tool
            end
        end
        task.wait(0.05) -- Reduced wait time for faster checking
    end
    return nil
end

local function autoActivateTool(tool)
    if activationConnection then
        activationConnection:Disconnect()
        activationConnection = nil
    end
    activationConnection = RunService.Heartbeat:Connect(function()
        if not Toggles[toggleName].Value then
            return
        end
        
        local character = LocalPlayer.Character
        if not character then
            return
        end
        
        local humanoid = character:FindFirstChild('Humanoid')
        if not humanoid then
            return
        end
        
        -- Check if tool is equipped, if not, auto-equip it
        local equippedTool = character:FindFirstChild('[HeavyWeights]')
        if not equippedTool then
            -- Try to find tool in backpack and equip it
            local backpackTool = Backpack:FindFirstChild('[HeavyWeights]')
            if backpackTool then
                humanoid:EquipTool(backpackTool)
                tool = backpackTool
            end
        else
            tool = equippedTool
        end
        
        -- Activate tool if equipped
        if tool and tool.Parent == character then
            pcall(function()
                tool:Activate()
            end)
        end
    end)
end

local function mainProcess()
    teleportTo(Vector3.new(-46.36, 23.57, -653.74))
    local shopItem = findShopItem()
    if not shopItem then
        return
    end
    fireClickDetector(shopItem)
    task.wait(0.5) -- Reduced wait time for faster operation
    teleportTo(Vector3.new(768.47, 112.62, -787.92))
    
    -- Ensure tool is equipped and start auto-activation
    local tool = equipTool('[HeavyWeights]')
    if tool then
        autoActivateTool(tool)
    else
        -- If tool not found, try again after a short delay
        task.wait(0.5)
        tool = equipTool('[HeavyWeights]')
        if tool then
            autoActivateTool(tool)
        end
    end
end

local function onToggleChanged(value)
    if not value then
        if activationConnection then
            activationConnection:Disconnect()
            activationConnection = nil
        end
        if respawnConnection then
            respawnConnection:Disconnect()
            respawnConnection = nil
        end
        if toolMonitorConnection then
            toolMonitorConnection:Disconnect()
            toolMonitorConnection = nil
        end
        
        -- Teleport back to original position when disabled
        if originalWeightPosition then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
                LocalPlayer.Character.HumanoidRootPart.CFrame = originalWeightPosition
            end
            originalWeightPosition = nil
        end
        return
    end
    
    -- Save original position when enabling
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        originalWeightPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
    end
    
    -- Start tool monitoring to auto-equip when unequipped
    if toolMonitorConnection then
        toolMonitorConnection:Disconnect()
        toolMonitorConnection = nil
    end
    
    toolMonitorConnection = RunService.Heartbeat:Connect(function()
        if not Toggles[toggleName].Value then
            return
        end
        
        local character = LocalPlayer.Character
        if not character then
            return
        end
        
        local humanoid = character:FindFirstChild('Humanoid')
        if not humanoid then
            return
        end
        
        -- Check if HeavyWeights is equipped, if not, try to equip it
        local equippedTool = character:FindFirstChild('[HeavyWeights]')
        if not equippedTool then
            local backpackTool = Backpack:FindFirstChild('[HeavyWeights]')
            if backpackTool then
                humanoid:EquipTool(backpackTool)
            end
        end
    end)
    
    task.spawn(mainProcess)
    if respawnConnection then
        respawnConnection:Disconnect()
        respawnConnection = nil
    end
    respawnConnection = LocalPlayer.CharacterAdded:Connect(function()
        task.wait(2)
        if Toggles[toggleName].Value then
            task.spawn(mainProcess)
        end
    end)
end

Toggles[toggleName]:OnChanged(onToggleChanged)

-- Player List Section
local playerListSection = tabs.lua:AddLeftGroupbox('PlayerList')

-- Get all players in the game
local function getAllPlayers()
    local players = {}
    for _, player in pairs(game.Players:GetPlayers()) do
        table.insert(players, {
            username = player.Name,
            displayName = player.DisplayName
        })
    end
    return players
end

-- Create dropdown with all players
local playerDropdown = playerListSection:AddDropdown('player_dropdown', {
    Values = {},
    Default = 1,
    Multi = false,
    Text = 'Select Player',
    Tooltip = 'Choose a player from the list',
    Callback = function(value)
        -- Handle player selection
        print('Selected player:', value)
    end,
})

-- Update dropdown values with current players
local function updatePlayerDropdown()
    local players = getAllPlayers()
    local playerNames = {}
    for _, player in ipairs(players) do
        table.insert(playerNames, player.username)
    end
    playerDropdown:SetValues(playerNames)
end

-- Initialize dropdown
updatePlayerDropdown()

-- Update dropdown when players join/leave
game.Players.PlayerAdded:Connect(function()
    task.wait(0.1) -- Small delay to ensure player is fully loaded
    updatePlayerDropdown()
end)

game.Players.PlayerRemoving:Connect(function()
    updatePlayerDropdown()
end)

-- Add live note label (positioned above search input)
local liveNote = playerListSection:AddLabel('result: ?', true)
liveNote.Name = 'live_note'

-- Search functionality
local lastValidMatch = nil -- Store the last valid player match

local searchInput = playerListSection:AddInput('player_search', {
    Text = 'player search',
    Tooltip = '$$$SUDO APT OPSEC',
    Placeholder = '',
    Callback = function(value)
        print('Search input changed to:', value)
        local players = getAllPlayers()
        print('Total players found:', #players)
        
        if value == '' then
            -- Empty input - show default
            liveNote:SetText('result: ?')
            lastValidMatch = nil
            return
        end
        
        local searchTerm = value:lower()
        local closestMatch = nil
        local closestDistance = math.huge
        
        -- Find closest match - first try exact prefix matches, then any contains matches
        local exactMatches = {}
        local containsMatches = {}
        
        for _, player in ipairs(players) do
            local username = player.username:lower()
            local displayName = player.displayName:lower()
            
            -- Check if search term matches username or display name (starts with search term)
            if username:sub(1, #searchTerm) == searchTerm or displayName:sub(1, #searchTerm) == searchTerm then
                table.insert(exactMatches, player)
            -- If no exact match, check if the letter exists anywhere in the name
            elseif username:find(searchTerm, 1, true) or displayName:find(searchTerm, 1, true) then
                table.insert(containsMatches, player)
            end
        end
        
        -- Prioritize exact matches first
        if #exactMatches > 0 then
            -- Calculate distance for exact matches (closest to start of name)
            for _, player in ipairs(exactMatches) do
                local username = player.username:lower()
                local displayName = player.displayName:lower()
                
                local usernameMatch = username:find(searchTerm, 1, true)
                local displayNameMatch = displayName:find(searchTerm, 1, true)
                
                local distance = math.huge
                if usernameMatch then
                    distance = math.min(distance, usernameMatch - 1)
                end
                if displayNameMatch then
                    distance = math.min(distance, displayNameMatch - 1)
                end
                
                if distance < closestDistance then
                    closestDistance = distance
                    closestMatch = player
                end
            end
        elseif #containsMatches > 0 then
            -- If no exact matches, pick the first contains match
            closestMatch = containsMatches[1]
        end
        
        print('Closest match found:', closestMatch and closestMatch.username or 'none')
        
        -- Update live note with closest match or keep last valid match
        if closestMatch then
            -- Store this as the last valid match
            lastValidMatch = closestMatch
            
            -- Show full username
            local displayUsername = closestMatch.username
            liveNote:SetText('result: ' .. displayUsername .. ' (' .. closestMatch.displayName .. ')')
            
            -- Auto-select the closest match in dropdown
            local playerNames = {}
            for _, player in ipairs(players) do
                table.insert(playerNames, player.username)
            end
            
            -- Update dropdown values first to ensure they're current
            playerDropdown:SetValues(playerNames)
            
            -- Find the index of the matched player and select it
            for i, name in ipairs(playerNames) do
                if name == closestMatch.username then
                    -- Try both methods to ensure selection works
                    task.wait(0.01)
                    playerDropdown:SetValue(i) -- Try by index
                    task.wait(0.01)
                    playerDropdown:SetValue(closestMatch.username) -- Try by value
                    print('Auto-selected player:', closestMatch.username, 'at index:', i)
                    break
                end
            end
        else
            -- No match found - keep showing the last valid match
            if lastValidMatch then
                local displayUsername = lastValidMatch.username
                liveNote:SetText('result: ' .. displayUsername .. ' (' .. lastValidMatch.displayName .. ')')
                print('No match found, keeping last valid match:', lastValidMatch.username)
            else
                liveNote:SetText('result: ')
            end
        end
    end,
})

-- ===========================================
-- KNOCK BUTTON FUNCTIONALITY
-- ===========================================

-- Knock Check Function
local function KnockCheck(player)
    if player and player.Character then
        local bodyEffects = player.Character:FindFirstChild("BodyEffects")
        if bodyEffects then
            local knockOut = bodyEffects:FindFirstChild("K.O")
            return knockOut and knockOut.Value == true
        end
    end
    return false
end

-- Sticky Silent Aim Variables
local stickyAimEnabled = false
local stickyAimTarget = nil
local originalNamecall = nil
local stickyAimActive = false -- Only redirect when actively shooting target

-- Knock Button State Variables
local knockSequenceActive = false
local savedOriginalPosition = nil

-- Forcefield Check Function
local function hasForcefield(player)
    if player and player.Character then
        local forcefield = player.Character:FindFirstChild("ForceField")
        return forcefield ~= nil
    end
    return false
end

-- Sticky Silent Aim Function
local function enableStickySilentAim(targetPlayer)
    if not targetPlayer then return end
    
    stickyAimEnabled = true
    stickyAimTarget = targetPlayer
    print('Sticky silent aim enabled for:', targetPlayer.Name)
    
    -- Hook the ShootGun remote to redirect shots to target
    if not originalNamecall then
        originalNamecall = getrawmetatable(game).__namecall
        
        getrawmetatable(game).__namecall = newcclosure(function(self, ...)
            local args = {...}
            local method = getnamecallmethod()
            
            if stickyAimEnabled and stickyAimTarget and stickyAimTarget.Character and stickyAimActive then
                if method == "FireServer" and self == MainEvent and args[1] == "ShootGun" then
                    print('Silent aim hook triggered for:', stickyAimTarget.Name)
                    -- Check for forcefield before redirecting
                    if hasForcefield(stickyAimTarget) then
                        print('Target has forcefield, skipping silent aim redirect for:', stickyAimTarget.Name)
                        -- Don't redirect the shot, let it go to original target
                    else
                        local targetHead = stickyAimTarget.Character:FindFirstChild("Head")
                        if targetHead then
                            -- Redirect shot to sticky aim target
                            args[4] = targetHead.Position
                            args[5] = targetHead
                            print('Silent aim redirected to:', stickyAimTarget.Name)
                        end
                    end
                end
            end
            
            return originalNamecall(self, ...)
        end)
    end
end

local function disableStickySilentAim()
    stickyAimEnabled = false
    stickyAimTarget = nil
    stickyAimActive = false
    print('Sticky silent aim disabled')
end

-- Main Event Setup
local MainEvent = nil
if game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent") then -- Da Hood
    MainEvent = game:GetService("ReplicatedStorage").MainEvent
elseif game:GetService("ReplicatedStorage"):FindFirstChild("MAINEVENT") then -- Idk Da Hood
    MainEvent = game:GetService("ReplicatedStorage").MAINEVENT
elseif game:GetService("ReplicatedStorage"):WaitForChild("MainRemotes"):WaitForChild("MainRemoteEvent") then -- Der Hood
    MainEvent = game:GetService("ReplicatedStorage"):WaitForChild("MainRemotes"):WaitForChild("MainRemoteEvent")
else
    print("Couldn't find MainEvent, game not supported.")
end

-- Add teleport and bring buttons with sub-buttons
local teleportButton = playerListSection:AddButton({
    Text = 'Teleport',
    Func = function()
        local selectedPlayer = playerDropdown.Value
        if selectedPlayer and selectedPlayer ~= '' then
            local targetPlayer = game.Players:FindFirstChild(selectedPlayer)
            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild('HumanoidRootPart') then
                local localPlayer = game.Players.LocalPlayer
                if localPlayer.Character and localPlayer.Character:FindFirstChild('HumanoidRootPart') then
                    -- Teleport onto their head (5 studs above their position)
                    local targetPosition = targetPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 5, 0)
                    localPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
                    print('Teleported onto head of:', selectedPlayer)
                end
            else
                print('Target player not found or not loaded:', selectedPlayer)
            end
        else
            print('No player selected')
        end
    end,
    DoubleClick = false,
    Tooltip = 'Teleport you to the selected target.',
})

-- Function to handle the actual knock sequence
local function proceedWithKnock(Target, selectedPlayer, localPlayer, humanoidRootPart, originalCFrame)
    local targetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
    local targetHead = Target.Character:FindFirstChild("Head")
    
    if targetHead and targetHRP then
        -- Enable sticky silent aim for this target
        enableStickySilentAim(Target)
        
        -- Initial teleport to target's head
        local targetHeadPos = targetHead.Position
        local stickToHeadPos = Vector3.new(targetHeadPos.X, targetHeadPos.Y + 5, targetHeadPos.Z)
        humanoidRootPart.CFrame = CFrame.new(stickToHeadPos)
        print('Teleported to head of:', selectedPlayer)
        
        -- Continuous auto-shooting loop until target is knocked
        task.spawn(function()
            while Target and Target.Character and not KnockCheck(Target) do
                -- Check if target left the game
                if not game.Players:FindFirstChild(selectedPlayer) then
                    api:notify(selectedPlayer .. " left the game", 5)
                    updatePlayerDropdown() -- Refresh player list
                    disableStickySilentAim()
                    return -- Exit the function
                end
                
                if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    break
                end
                
                local currentTool = localPlayer.Character:FindFirstChildOfClass("Tool")
                if not currentTool or not currentTool:FindFirstChild("Handle") then
                    print('No gun equipped, stopping knock sequence')
                    break
                end
                
                local currentTargetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
                local currentTargetHead = Target.Character:FindFirstChild("Head")
                
                if currentTargetHRP and currentTargetHead then
                    -- FIRMLY stick to target's head - no lag, no movement issues
                    local targetHeadPos = currentTargetHead.Position
                    local stickToHeadPos = Vector3.new(targetHeadPos.X, targetHeadPos.Y + 5, targetHeadPos.Z)
                    
                    -- Force position update every frame for firm sticking
                    humanoidRootPart.CFrame = CFrame.new(stickToHeadPos)
                    humanoidRootPart.Position = stickToHeadPos
                    
                    if hasForcefield(Target) then
                        -- Target has forcefield, wait without shooting but keep sticking
                        print('Target has forcefield, waiting but staying stuck to head...')
                        task.wait(0.1) -- Shorter wait to maintain firm sticking
                    else
                        -- Auto-shoot multiple times rapidly while firmly stuck to head
                        for i = 1, 3 do
                            if Target and Target.Character and not KnockCheck(Target) and not hasForcefield(Target) then
                                -- Maintain firm position while shooting
                                humanoidRootPart.CFrame = CFrame.new(stickToHeadPos)
                                humanoidRootPart.Position = stickToHeadPos
                                
                                -- Enable sticky aim only when actively shooting
                                stickyAimActive = true
                                print('About to shoot with sticky aim at:', selectedPlayer)
                                MainEvent:FireServer("ShootGun", currentTool.Handle, currentTool.Handle.Position, currentTargetHead.Position, currentTargetHead, Vector3.new(0, 1, 0))
                                print('Firm head shot', i, 'at:', selectedPlayer)
                                task.wait(0.01) -- Small delay before disabling
                                stickyAimActive = false -- Disable after shooting
                                task.wait(0.05) -- Very fast shooting
                            else
                                if hasForcefield(Target) then
                                    print('Forcefield detected during shooting, stopping shots but staying stuck')
                                end
                                break
                            end
                        end
                    end
                else
                    print('Target lost, stopping knock sequence')
                    break
                end
                
                task.wait(0.01) -- Very short wait for maximum sticking performance
            end
            
            -- Check if target was successfully knocked
            if Target and Target.Character and KnockCheck(Target) then
                print('Successfully knocked player:', selectedPlayer)
            else
                print('Failed to knock player or target left:', selectedPlayer)
            end
            
            -- Disable sticky silent aim
            disableStickySilentAim()
            
            -- Teleport back to original position
            if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                localPlayer.Character.HumanoidRootPart.CFrame = originalCFrame
                print('Teleported back to original position')
            end
        end)
    end
end

-- KNOCK BUTTON - This is the main functionality you requested
local teleportSubButton = teleportButton:AddButton({
    Text = 'Knock',
    Func = function()
        local selectedPlayer = playerDropdown.Value
        if selectedPlayer and selectedPlayer ~= '' then
            local Target = game.Players:FindFirstChild(selectedPlayer)
            local localPlayer = game.Players.LocalPlayer
            
            if Target and Target.Character and localPlayer.Character then
                local originalCFrame = localPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame
                local humanoidRootPart = localPlayer.Character:FindFirstChild("HumanoidRootPart")
                local Tool = localPlayer.Character:FindFirstChildOfClass("Tool")
                
                if humanoidRootPart and Tool and Tool:FindFirstChild("Handle") then
                    local targetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
                    local targetHead = Target.Character:FindFirstChild("Head")
                    
                    if targetHead and targetHRP then
                        print('Starting knock sequence for:', selectedPlayer)
                        
                        -- Check if player is already knocked out
                        if KnockCheck(Target) then
                            api:notify(selectedPlayer .. " is already knocked.", 2)
                            return -- Exit the function
                        end
                        
                        -- Check if target has forcefield before starting
                        if hasForcefield(Target) then
                            -- Use api:notify for forcefield notification
                            api:notify(selectedPlayer .. " is in an active protective barrier. Waiting...", 10)
                            
                            -- Wait for forcefield to end
                            task.spawn(function()
                                while hasForcefield(Target) and Target and Target.Character do
                                    -- Check if target left the game
                                    if not game.Players:FindFirstChild(selectedPlayer) then
                                        api:notify(selectedPlayer .. " left the game", 5)
                                        updatePlayerDropdown() -- Refresh player list
                                        return -- Exit the function
                                    end
                                    task.wait(0.1)
                                end
                                
                                -- Now proceed with the knock sequence
                                if Target and Target.Character then
                                    proceedWithKnock(Target, selectedPlayer, localPlayer, humanoidRootPart, originalCFrame)
                                end
                            end)
                        else
                            -- No forcefield, proceed immediately
                            proceedWithKnock(Target, selectedPlayer, localPlayer, humanoidRootPart, originalCFrame)
                        end
                    else
                        print('Target missing head or rootpart')
                    end
                else
                    print('Please equip your gun before using Knock')
                end
            else
                print('Target player not found or not loaded:', selectedPlayer)
            end
        else
            print('No player selected for knock')
        end
    end,
    DoubleClick = false,
})

local testButton = playerListSection:AddButton({
    Text = 'Soon',
    Func = function()
        print('Soon button pressed - feature coming soon!')
    end,
    DoubleClick = false,
})

-- Function to handle the actual bring sequence
local function proceedWithBring(Target, selectedPlayer, localPlayer, humanoidRootPart, originalCFrame)
    local targetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
    local targetHead = Target.Character:FindFirstChild("Head")
    
    if targetHead and targetHRP then
        -- Enable sticky silent aim for this target
        enableStickySilentAim(Target)
        
        -- Initial teleport to target's head
        local targetHeadPos = targetHead.Position
        local stickToHeadPos = Vector3.new(targetHeadPos.X, targetHeadPos.Y + 5, targetHeadPos.Z)
        humanoidRootPart.CFrame = CFrame.new(stickToHeadPos)
        print('Teleported to head of:', selectedPlayer)
        
        -- Continuous auto-shooting loop until target is knocked or gun is unequipped
        task.spawn(function()
            while Target and Target.Character and not KnockCheck(Target) do
                -- Check if target left the game
                if not game.Players:FindFirstChild(selectedPlayer) then
                    api:notify(selectedPlayer .. " left the game", 5)
                    updatePlayerDropdown() -- Refresh player list
                    disableStickySilentAim()
                    return -- Exit the function
                end
                
                if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    print('Character lost, stopping bring sequence')
                    break
                end
                
                local currentTool = localPlayer.Character:FindFirstChildOfClass("Tool")
                if not currentTool or not currentTool:FindFirstChild("Handle") then
                    print('Gun unequipped, stopping bring sequence')
                    break
                end
                
                local currentTargetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
                local currentTargetHead = Target.Character:FindFirstChild("Head")
                
                if currentTargetHRP and currentTargetHead then
                    -- FIRMLY stick to target's head - no lag, no movement issues
                    local targetHeadPos = currentTargetHead.Position
                    local stickToHeadPos = Vector3.new(targetHeadPos.X, targetHeadPos.Y + 5, targetHeadPos.Z)
                    
                    -- Force position update every frame for firm sticking
                    humanoidRootPart.CFrame = CFrame.new(stickToHeadPos)
                    humanoidRootPart.Position = stickToHeadPos
                    
                    if hasForcefield(Target) then
                        -- Target has forcefield, wait without shooting but keep sticking
                        print('Target has forcefield, waiting but staying stuck to head...')
                        task.wait(0.1) -- Shorter wait to maintain firm sticking
                    else
                        -- Auto-shoot multiple times rapidly while firmly stuck to head
                        for i = 1, 3 do
                            if Target and Target.Character and not KnockCheck(Target) and not hasForcefield(Target) then
                                -- Maintain firm position while shooting
                                humanoidRootPart.CFrame = CFrame.new(stickToHeadPos)
                                humanoidRootPart.Position = stickToHeadPos
                                
                                -- Enable sticky aim only when actively shooting
                                stickyAimActive = true
                                print('About to shoot with sticky aim at:', selectedPlayer)
                                MainEvent:FireServer("ShootGun", currentTool.Handle, currentTool.Handle.Position, currentTargetHead.Position, currentTargetHead, Vector3.new(0, 1, 0))
                                print('Bring head shot', i, 'at:', selectedPlayer)
                                task.wait(0.01) -- Small delay before disabling
                                stickyAimActive = false -- Disable after shooting
                                task.wait(0.05) -- Very fast shooting
                            else
                                if hasForcefield(Target) then
                                    print('Forcefield detected during shooting, stopping shots but staying stuck')
                                end
                                break
                            end
                        end
                    end
                else
                    print('Target lost, stopping bring sequence')
                    break
                end
                
                task.wait(0.01) -- Very short wait for maximum sticking performance
            end
            
            -- Check if target was successfully knocked
            if Target and Target.Character and KnockCheck(Target) then
                print('Successfully knocked player:', selectedPlayer, '- Staying frozen on head while they ragdoll...')
                
                -- Stay frozen on the target's head and pick up once
                local originalHeadPos = Target.Character.Head.Position
                local pickupAttempted = false
                
                -- Wait briefly for ragdoll to settle
                print('Waiting for ragdoll to settle before pickup...')
                task.wait(0.5) -- Reduced from 2 to 0.5 seconds
                
                -- Go to the current head position and pick up once
                if Target.Character and Target.Character:FindFirstChild("Head") then
                    local currentHeadPos = Target.Character.Head.Position
                    local stickToHeadPos = Vector3.new(currentHeadPos.X, currentHeadPos.Y + 5, currentHeadPos.Z)
                    
                    -- Stay frozen on head
                    humanoidRootPart.CFrame = CFrame.new(stickToHeadPos)
                    humanoidRootPart.Position = stickToHeadPos
                    
                    print('Positioned on ragdolled head, attempting fast pickup...')
                    
                    -- Press G once to pick up
                    local VirtualInputManager = game:GetService("VirtualInputManager")
                    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.G, false, game)
                    task.wait(0.05) -- Reduced from 0.1 to 0.05
                    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.G, false, game)
                    print('Pressed G once to pick up body')
                    
                    pickupAttempted = true
                    
                    -- Wait briefly for pickup animation
                    task.wait(0.5) -- Reduced from 1.5 to 0.5 seconds
                    
                    print('Pickup attempted, teleporting back quickly...')
                end
                
                -- Always teleport back to original position
                if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    localPlayer.Character.HumanoidRootPart.CFrame = originalCFrame
                    print('Teleported back to original position')
                end
            else
                print('Failed to knock player or target left:', selectedPlayer)
                -- Return to original position if knock failed
                if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    localPlayer.Character.HumanoidRootPart.CFrame = originalCFrame
                    print('Returned to original position (knock failed)')
                end
            end
            
            -- Disable sticky silent aim
            disableStickySilentAim()
        end)
    end
end

local stompSubButton = testButton:AddButton({
    Text = 'Bring',
    Func = function()
        local selectedPlayer = playerDropdown.Value
        if selectedPlayer and selectedPlayer ~= '' then
            local Target = game.Players:FindFirstChild(selectedPlayer)
            local localPlayer = game.Players.LocalPlayer
            
            if Target and Target.Character and localPlayer.Character then
                local originalCFrame = localPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame
                local humanoidRootPart = localPlayer.Character:FindFirstChild("HumanoidRootPart")
                local Tool = localPlayer.Character:FindFirstChildOfClass("Tool")
                
                if humanoidRootPart and Tool and Tool:FindFirstChild("Handle") then
                    local targetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
                    local targetHead = Target.Character:FindFirstChild("Head")
                    
                    if targetHead and targetHRP then
                        print('Starting bring sequence for:', selectedPlayer)
                        
                        -- Check if target has forcefield before starting
                        if hasForcefield(Target) then
                            -- Use api:notify for forcefield notification
                            api:notify(selectedPlayer .. " is in an active protective barrier. Waiting...", 10)
                            
                            -- Wait for forcefield to end
                            task.spawn(function()
                                while hasForcefield(Target) and Target and Target.Character do
                                    -- Check if target left the game
                                    if not game.Players:FindFirstChild(selectedPlayer) then
                                        api:notify(selectedPlayer .. " left the game", 5)
                                        updatePlayerDropdown() -- Refresh player list
                                        return -- Exit the function
                                    end
                                    task.wait(0.1)
                                end
                                
                                -- Now proceed with the bring sequence
                                if Target and Target.Character then
                                    proceedWithBring(Target, selectedPlayer, localPlayer, humanoidRootPart, originalCFrame)
                                end
                            end)
                        else
                            -- No forcefield, proceed immediately
                            proceedWithBring(Target, selectedPlayer, localPlayer, humanoidRootPart, originalCFrame)
                        end
                    else
                        print('Target missing head or rootpart')
                    end
                else
                    print('Please equip your gun before using Bring')
                end
            else
                print('Target player not found or not loaded:', selectedPlayer)
            end
        else
            print('No player selected for bring')
        end
    end,
    DoubleClick = false,
})

playerListSection:AddLabel('@wanderkidd', true)
