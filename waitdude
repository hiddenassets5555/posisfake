if getgenv().wanderkiddfakepos_loaded then
    return
end
getgenv().wanderkiddfakepos_loaded = true

local api = getfenv().api or {}
local M = {}

-- Skyboxes data from skyboxes.lua
local skyBoxes = {
	["purple clouds"] = {
		SkyboxLf = "rbxassetid://151165191",
		SkyboxBk = "rbxassetid://151165214",
		SkyboxDn = "rbxassetid://151165197",
		SkyboxFt = "rbxassetid://151165224",
		SkyboxRt = "rbxassetid://151165206",
		SkyboxUp = "rbxassetid://151165227",
	},
	["cloudy skies"] = {
		SkyboxLf = "rbxassetid://151165191",
		SkyboxBk = "rbxassetid://151165214",
		SkyboxDn = "rbxassetid://151165197",
		SkyboxFt = "rbxassetid://151165224",
		SkyboxRt = "rbxassetid://151165206",
		SkyboxUp = "rbxassetid://151165227",
	},
	["purple nebula"] = {
		SkyboxLf = "rbxassetid://159454286",
		SkyboxBk = "rbxassetid://159454299",
		SkyboxDn = "rbxassetid://159454296",
		SkyboxFt = "rbxassetid://159454293",
		SkyboxRt = "rbxassetid://159454300",
		SkyboxUp = "rbxassetid://159454288",
	},
	["purple and blue"] = {
		SkyboxLf = "rbxassetid://149397684",
		SkyboxBk = "rbxassetid://149397692",
		SkyboxDn = "rbxassetid://149397686",
		SkyboxFt = "rbxassetid://149397697",
		SkyboxRt = "rbxassetid://149397688",
		SkyboxUp = "rbxassetid://149397702",
	},
	["twighlight"] = {
		SkyboxLf = "rbxassetid://264909758",
		SkyboxBk = "rbxassetid://264908339",
		SkyboxDn = "rbxassetid://264907909",
		SkyboxFt = "rbxassetid://264909420",
		SkyboxRt = "rbxassetid://264908886",
		SkyboxUp = "rbxassetid://264907379",
	},
	["vaporwave"] = {
		SkyboxLf = "rbxassetid://1417494402",
		SkyboxBk = "rbxassetid://1417494030",
		SkyboxDn = "rbxassetid://1417494146",
		SkyboxFt = "rbxassetid://1417494253",
		SkyboxLf = "rbxassetid://1417494402",
		SkyboxRt = "rbxassetid://1417494499",
		SkyboxUp = "rbxassetid://1417494643",
	},
	["clouds"] = {
		SkyboxLf = "rbxassetid://570557620",
		SkyboxBk = "rbxassetid://570557514",
		SkyboxDn = "rbxassetid://570557775",
		SkyboxFt = "rbxassetid://570557559",
		SkyboxLf = "rbxassetid://570557620",
		SkyboxRt = "rbxassetid://570557672",
		SkyboxUp = "rbxassetid://570557727",
	},
	["setting sun"] = {
		SkyboxBk = "rbxassetid://626460377",
		SkyboxDn = "rbxassetid://626460216",
		SkyboxFt = "rbxassetid://626460513",
		SkyboxLf = "rbxassetid://626473032",
		SkyboxRt = "rbxassetid://626458639",
		SkyboxUp = "rbxassetid://626460625"
	},
	["fade blue"] = {
		SkyboxBk = "rbxassetid://153695414",
		SkyboxDn = "rbxassetid://153695352",
		SkyboxFt = "rbxassetid://153695452",
		SkyboxLf = "rbxassetid://153695320",
		SkyboxRt = "rbxassetid://153695383",
		SkyboxUp = "rbxassetid://153695471"
	},
	["elegant morning"] = {
		SkyboxBk = "rbxassetid://153767241",
		SkyboxDn = "rbxassetid://153767216",
		SkyboxFt = "rbxassetid://153767266",
		SkyboxLf = "rbxassetid://153767200",
		SkyboxRt = "rbxassetid://153767231",
		SkyboxUp = "rbxassetid://153767288"
	},
	["neptune"] = {
		SkyboxBk = "rbxassetid://218955819",
		SkyboxDn = "rbxassetid://218953419",
		SkyboxFt = "rbxassetid://218954524",
		SkyboxLf = "rbxassetid://218958493",
		SkyboxRt = "rbxassetid://218957134",
		SkyboxUp = "rbxassetid://218950090"
	},
	["redshift"] = {
		SkyboxBk = "rbxassetid://401664839",
		SkyboxDn = "rbxassetid://401664862",
		SkyboxFt = "rbxassetid://401664960",
		SkyboxLf = "rbxassetid://401664881",
		SkyboxRt = "rbxassetid://401664901",
		SkyboxUp = "rbxassetid://401664936"
	},
	["aesthetic night"] = {
		SkyboxBk = "rbxassetid://1045964490",
		SkyboxDn = "rbxassetid://1045964368",
		SkyboxFt = "rbxassetid://1045964655",
		SkyboxLf = "rbxassetid://1045964655",
		SkyboxRt = "rbxassetid://1045964655",
		SkyboxUp = "rbxassetid://1045962969"
	}
}

-- Create dropdown values array
local skyboxDropDown = {}
for i, v in next, (skyBoxes) do
	skyboxDropDown[1 + #skyboxDropDown] = i
end

local tabs = getgenv().wanderkidd_tabs or {
    lua = api:AddTab('$API'),
}
getgenv().wanderkidd_tabs = tabs

local networkSection = tabs.lua:AddLeftGroupbox('Shadow-Clone Jutsu')

local settingsTabBox = tabs.lua:AddRightTabbox()

local infoTab = settingsTabBox:AddTab('Info')
infoTab:AddLabel(
    'Note: The secret is not to find the meaning of life, but to use your life to make things that are meaningful.',
    true
)

local settingsTab = settingsTabBox:AddTab('Settings')

-- Skyboxes functionality
local skyboxesEnabled = false
local currentSkybox = "elegant morning"

-- Function to apply skybox
local function applySkybox(skyboxName)
    local skyboxData = skyBoxes[skyboxName]
    if not skyboxData then 
        return 
    end
    
    local lighting = game:GetService("Lighting")
    
    -- Get or create Sky object
    local skyObject = lighting:FindFirstChild("Sky")
    if not skyObject then
        skyObject = Instance.new("Sky")
        skyObject.Parent = lighting
    end
    
    -- Apply skybox textures
    skyObject.SkyboxLf = skyboxData.SkyboxLf
    skyObject.SkyboxBk = skyboxData.SkyboxBk
    skyObject.SkyboxDn = skyboxData.SkyboxDn
    skyObject.SkyboxFt = skyboxData.SkyboxFt
    skyObject.SkyboxRt = skyboxData.SkyboxRt
    skyObject.SkyboxUp = skyboxData.SkyboxUp
end

-- Skyboxes checkbox
local skyboxesToggle = settingsTab:AddToggle('skyboxes_enabled', {
    Text = 'Skyboxes',
    Default = false,
    Callback = function(value)
        skyboxesEnabled = value
        if value then
            applySkybox(currentSkybox)
        else
            -- Reset to original game skybox when disabled
            local lighting = game:GetService("Lighting")
            
            -- Remove the Sky object completely to restore original game skybox
            local skyObject = lighting:FindFirstChild("Sky")
            if skyObject then
                skyObject:Destroy()
            end
        end
    end,
})

-- Create dependency box for skyboxes dropdown
local skyboxesDepbox = settingsTab:AddDependencyBox()

-- Skyboxes dropdown (only visible when checkbox is enabled)
skyboxesDepbox:AddDropdown('skybox_selection', {
    Text = 'Skybox Selection',
    Default = 'elegant morning',
    Values = skyboxDropDown,
    Callback = function(value)
        currentSkybox = value
        applySkybox(value)
    end,
})

-- Setup dependency - dropdown only shows when checkbox is enabled
skyboxesDepbox:SetupDependencies({
    { skyboxesToggle, true }
})


getgenv().wanderkiddfakepos = getgenv().wanderkiddfakepos or {}
local wanderkiddfakepos = getgenv().wanderkiddfakepos

wanderkiddfakepos.Network = wanderkiddfakepos.Network
    or {
        FakePos = false,
        Desync = false,
        UseSenderRate = true,
        SenderRate = 1,
        RefreshRate = 0.1,
    }

local framework = {}
framework.keybindPressed = false

-- Enhanced fake position implementation - Server-side freeze with local movement
local RunService = game:GetService("RunService")
local LocalPlayer = game:GetService("Players").LocalPlayer
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local a = false
local serverFrozenPosition = nil
local isServerFrozen = false
local originalNetworkOwner = nil

-- Store server position when fake pos is enabled
local function storeServerPosition()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        serverFrozenPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
    end
end

-- Enhanced network manipulation for server-side only freezing
if not wanderkiddfakepos._connection then
    wanderkiddfakepos._connection = RunService.Heartbeat:Connect(function()
        if wanderkiddfakepos.Network.Desync and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = LocalPlayer.Character.HumanoidRootPart
            
            -- Store server position on first activation
            if not isServerFrozen then
                storeServerPosition()
                isServerFrozen = true
                -- Store original network owner
                originalNetworkOwner = hrp:GetNetworkOwner()
            end
            
            -- Aggressive network manipulation for server-side freezing
            sethiddenproperty(hrp, "NetworkIsSleeping", true)
            
            -- Manipulate network ownership to control server position
            if hrp:GetNetworkOwner() == LocalPlayer then
                hrp:SetNetworkOwner(nil) -- Remove network ownership
            end
            
            -- Send fake position to server (this is what other players see)
            if serverFrozenPosition then
                -- Use remote events or direct network manipulation
                pcall(function()
                    -- Force server to see frozen position
                    hrp.CFrame = serverFrozenPosition
                    hrp.Velocity = Vector3.new(0, 0, 0)
                    hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end)
            end
            
            -- Aggressive physics rate manipulation for server desync
            if wanderkiddfakepos.Network.UseSenderRate then
                setfflag("S2PhysicsSenderRate", "0.01")
                setfflag("S2PhysicsReceiverRate", "0.01")
            end
        else
            -- Reset when disabled
            if isServerFrozen then
                isServerFrozen = false
                serverFrozenPosition = nil
                -- Restore network ownership
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = LocalPlayer.Character.HumanoidRootPart
                    if originalNetworkOwner then
                        hrp:SetNetworkOwner(originalNetworkOwner)
                    end
                end
            end
        end
    end)
end

-- Local movement connection - allows free movement on client while server is frozen
if not wanderkiddfakepos._localConnection then
    wanderkiddfakepos._localConnection = RunService.Heartbeat:Connect(function()
        if wanderkiddfakepos.Network.Desync and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = LocalPlayer.Character.HumanoidRootPart
            
            -- Allow local movement by temporarily restoring network ownership
            if hrp:GetNetworkOwner() ~= LocalPlayer then
                hrp:SetNetworkOwner(LocalPlayer)
            end
            
            -- Immediately remove network ownership after setting position to prevent server sync
            task.defer(function()
                if hrp:GetNetworkOwner() == LocalPlayer then
                    hrp:SetNetworkOwner(nil)
                end
            end)
        end
    end)
end

-- Enhanced coroutine for network manipulation
if not wanderkiddfakepos._coroutine then
    wanderkiddfakepos._coroutine = coroutine.wrap(function()
        while true do
            if wanderkiddfakepos.Network.Desync then
                -- Aggressive network manipulation for server desync
                setfflag("S2PhysicsSenderRate", "0.001")
                setfflag("S2PhysicsReceiverRate", "0.001")
                
                -- Additional network flags for better desync
                setfflag("S2PhysicsSenderRate", "0.01")
                task.defer(function()
                    setfflag("S2PhysicsSenderRate", "0.1")
                    setfflag("S2PhysicsReceiverRate", "0.1")
                end)
                
                -- Force server position update
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and serverFrozenPosition then
                    local hrp = LocalPlayer.Character.HumanoidRootPart
                    -- Send frozen position to server
                    hrp:SetNetworkOwner(nil)
                    hrp.CFrame = serverFrozenPosition
                    hrp.Velocity = Vector3.new(0, 0, 0)
                    hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end
            end
            task.wait(0.001) -- Ultra-fast refresh rate for better desync
        end
    end)
    wanderkiddfakepos._coroutine()
end

if not wanderkiddfakepos._toggleCreated then
    networkSection:AddLabel("Fake Position")
    local fakeposToggle = networkSection:AddToggle('fakepos_enabled', {
        Text = 'Fake Pos',
        Default = wanderkiddfakepos.Network.Desync,
        Callback = function(value)
            wanderkiddfakepos.Network.Desync = value
            wanderkiddfakepos.Network.FakePos = value
            if value then
                -- Enhanced activation - store server position for freezing
                storeServerPosition()
                setfflag("S2PhysicsSenderRate", "0.001")
                setfflag("S2PhysicsReceiverRate", "0.001")
                task.defer(function()
                    setfflag("S2PhysicsSenderRate", "0.1")
                    setfflag("S2PhysicsReceiverRate", "0.1")
                end)
            else
                -- Enhanced deactivation and reset
                isServerFrozen = false
                serverFrozenPosition = nil
                pcall(function()
                    local character = game.Players.LocalPlayer.Character
                    if character and character:FindFirstChild('HumanoidRootPart') then
                        local hrp = character.HumanoidRootPart
                        sethiddenproperty(hrp, 'NetworkIsSleeping', false)
                        -- Restore network ownership
                        if originalNetworkOwner then
                            hrp:SetNetworkOwner(originalNetworkOwner)
                        end
                        -- Reset velocities
                        hrp.Velocity = Vector3.new(0, 0, 0)
                        hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                    end
                end)
                -- Reset network flags to normal
                setfflag("S2PhysicsSenderRate", "20")
                setfflag("S2PhysicsReceiverRate", "20")
            end
        end,
    })

    networkSection:AddDivider()
    
    networkSection:AddLabel('Toggle Key'):AddKeyPicker('fakepos_keybind', {
        Default = 'F',
        Mode = 'Toggle',
        Text = 'Fake Pos [Shadow-Clone Jutsu]',
        NoUI = false,
        Callback = function()
            if framework.keybindPressed then
                return
            end
            framework.keybindPressed = true
            fakeposToggle:SetValue(not fakeposToggle.Value)
            task.delay(0.2, function()
                framework.keybindPressed = false
            end)
        end,
    })

    wanderkiddfakepos._toggleCreated = true
end

local TabBox = tabs.lua:AddRightTabbox()

local Tab1 = TabBox:AddTab('Misc01')
local Tab2 = TabBox:AddTab('Misc02')
local Tab3 = TabBox:AddTab('Farm')

-- RPG Detection
getgenv().AntiRPGEnabled = false
getgenv().AntiRPGLoop = nil

-- Grenade Detection  
getgenv().AntiGrenadeEnabled = false
getgenv().AntiGrenadeLoop = nil

local RunService = game:GetService('RunService')
local Workspace = game:GetService('Workspace')
local LocalPlayer = game.Players.LocalPlayer
local ReplicatedStorage = game:GetService('ReplicatedStorage')

local function IsRPGNear()
    local Ignored = Workspace:FindFirstChild('Ignored')
    if not Ignored then
        return false
    end
    local HRP = LocalPlayer.Character
        and LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
    if not HRP then
        return false
    end
    local RPG = Ignored:FindFirstChild('Model')
        and Ignored.Model:FindFirstChild('Launcher')
    return RPG ~= nil
end

local function IsGrenadeNear()
    local Ignored = Workspace:FindFirstChild('Ignored')
    if not Ignored then
        return false
    end
    local HRP = LocalPlayer.Character
        and LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
    if not HRP then
        return false
    end
    local Grenade = Ignored:FindFirstChild('Handle')
    local grenadeNear = Grenade
        and (Grenade.Position - HRP.Position).Magnitude < 16
    return grenadeNear
end

local function StartRPGDetection()
    if getgenv().AntiRPGLoop then
        return
    end
    getgenv().AntiRPGLoop = RunService.PostSimulation:Connect(function()
        if not getgenv().AntiRPGEnabled then
            return
        end
        local Character = LocalPlayer.Character
        local HRP = Character and Character:FindFirstChild('HumanoidRootPart')
        local Humanoid = Character and Character:FindFirstChild('Humanoid')
        if not HRP or not Humanoid then
            return
        end
        if IsRPGNear() then
            local Offset = Vector3.new(
                math.random(-100, 100),
                math.random(50, 150),
                math.random(-100, 100)
            )
            Humanoid.CameraOffset = -Offset
            local OldCFrame = HRP.CFrame
            HRP.CFrame = CFrame.new(HRP.Position + Offset)
            RunService.RenderStepped:Wait()
            HRP.CFrame = OldCFrame
        end
    end)
    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        if getgenv().AntiRPGEnabled then
            StartRPGDetection()
        end
    end)
end

local function StopRPGDetection()
    if getgenv().AntiRPGLoop then
        getgenv().AntiRPGLoop:Disconnect()
        getgenv().AntiRPGLoop = nil
    end
end

local function StartGrenadeDetection()
    if getgenv().AntiGrenadeLoop then
        return
    end
    getgenv().AntiGrenadeLoop = RunService.PostSimulation:Connect(function()
        if not getgenv().AntiGrenadeEnabled then
            return
        end
        local Character = LocalPlayer.Character
        local HRP = Character and Character:FindFirstChild('HumanoidRootPart')
        local Humanoid = Character and Character:FindFirstChild('Humanoid')
        if not HRP or not Humanoid then
            return
        end
        if IsGrenadeNear() then
            local Offset = Vector3.new(
                math.random(-100, 100),
                math.random(50, 150),
                math.random(-100, 100)
            )
            Humanoid.CameraOffset = -Offset
            local OldCFrame = HRP.CFrame
            HRP.CFrame = CFrame.new(HRP.Position + Offset)
            RunService.RenderStepped:Wait()
            HRP.CFrame = OldCFrame
        end
    end)
    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        if getgenv().AntiGrenadeEnabled then
            StartGrenadeDetection()
        end
    end)
end

local function StopGrenadeDetection()
    if getgenv().AntiGrenadeLoop then
        getgenv().AntiGrenadeLoop:Disconnect()
        getgenv().AntiGrenadeLoop = nil
    end
end

Tab1:AddToggle('RPGDetection', {
    Text = 'RPG Detection',
    Default = false,
    Callback = function(state)
        getgenv().AntiRPGEnabled = state
        if state then
            StartRPGDetection()
        else
            StopRPGDetection()
        end
    end,
})

Tab1:AddToggle('GrenadeDetection', {
    Text = 'Grenade Detection',
    Default = false,
    Callback = function(state)
        getgenv().AntiGrenadeEnabled = state
        if state then
            StartGrenadeDetection()
        else
            StopGrenadeDetection()
        end
    end,
})


local CASH_AURA_ENABLED = false
local CASH_AURA_SPEED = 5
local CASH_AURA_RANGE = 10
local _CASH_AURA_LAST_CLICK = {}
local CASH_AURA_HUMANIZE = false

local function GetCash()
    local Found = {}
    local Drop = workspace:FindFirstChild('Ignored')
        and workspace.Ignored:FindFirstChild('Drop')

    local effectiveRange = CASH_AURA_HUMANIZE and 14 or CASH_AURA_RANGE

    if Drop then
        for _, v in pairs(Drop:GetChildren()) do
            if v.Name == 'MoneyDrop' then
                local Pos = v:GetAttribute('OriginalPos') or v.Position

                if
                    game.Players.LocalPlayer.Character
                    and game.Players.LocalPlayer.Character:FindFirstChild(
                        'HumanoidRootPart'
                    )
                    and (
                            Pos
                            - game.Players.LocalPlayer.Character.HumanoidRootPart.Position
                        ).Magnitude
                        <= effectiveRange
                then
                    table.insert(Found, v)
                end
            end
        end
    end

    return Found
end

local function CashAura()
    while CASH_AURA_ENABLED do
        local Cash = GetCash()
        local now = tick()
        local cooldown = CASH_AURA_HUMANIZE and (math.random(20, 50) / 100) or math.max(0.02, 1 / math.max(1, CASH_AURA_SPEED))

        if CASH_AURA_HUMANIZE then
            -- Occasionally skip to mimic human hesitation
            if math.random() < 0.1 then
                task.wait(cooldown)
            else
                -- Click at most one: the nearest drop
                local nearest, nearestDist
                local hrp = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
                for _, v in pairs(Cash) do
                    if hrp then
                        local pos = v:GetAttribute('OriginalPos') or v.Position
                        local d = (pos - hrp.Position).Magnitude
                        if not nearestDist or d < nearestDist then
                            nearest, nearestDist = v, d
                        end
                    end
                end
                if nearest then
                    local cd = nearest:FindFirstChildOfClass('ClickDetector')
                    if cd then
                        local last = _CASH_AURA_LAST_CLICK[nearest]
                        if not last or (now - last) >= 0.8 then
                            _CASH_AURA_LAST_CLICK[nearest] = now
                            pcall(function()
                                fireclickdetector(cd)
                            end)
                        end
                    end
                end
            end
        else
            for _, v in pairs(Cash) do
                local clickDetector = v:FindFirstChildOfClass('ClickDetector')
                if clickDetector then
                    local last = _CASH_AURA_LAST_CLICK[v]
                    if not last or (now - last) >= 0.5 then
                        _CASH_AURA_LAST_CLICK[v] = now
                        pcall(function()
                            fireclickdetector(clickDetector)
                        end)
                    end
                end
            end
        end

        task.wait(cooldown)
    end
end

local cash_aura_toggle = Tab1:AddToggle('Cash_Aura_Toggle', {
    Text = 'Cash Aura',
    Default = false,
    Callback = function(Value)
        CASH_AURA_ENABLED = Value
        if CASH_AURA_ENABLED then
            task.spawn(CashAura)
        else
            _CASH_AURA_LAST_CLICK = {}
        end
    end,
})

local cash_aura_depbox = Tab1:AddDependencyBox()
cash_aura_depbox:AddToggle('CashAuraHumanize', {
    Text = 'humanize',
    Default = false,
    Callback = function(v)
        CASH_AURA_HUMANIZE = v
    end,
})
cash_aura_depbox:AddSlider('CashAuraSpeed', {
    Text = 'Speed',
    Min = 1,
    Max = 10,
    Default = CASH_AURA_SPEED,
    Rounding = 0,
    Suffix = '',
    Compact = true,
    Callback = function(v)
        CASH_AURA_SPEED = v
    end,
})

cash_aura_depbox:AddSlider('CashAuraRange', {
    Text = 'Range',
    Min = 5,
    Max = 20,
    Default = CASH_AURA_RANGE,
    Rounding = 0,
    Suffix = '°',
    Compact = true,
    Callback = function(v)
        CASH_AURA_RANGE = v
    end,
})

cash_aura_depbox:SetupDependencies({
    { cash_aura_toggle, true }
})

-- FireArmor Auto-Buy System
local FIREARMOR_ENABLED = false
local FIREARMOR_MONITORING_TASK = nil
local shopCFrame = CFrame.new(-1176.60, 31.50, -478.90)

-- Function to buy Fire Armor
local function buyFireArmor()
    local ignored = workspace:FindFirstChild("Ignored")
    if not ignored then return false end
    local shop = ignored:FindFirstChild("Shop")
    if not shop then return false end
    local fireArmor = shop:FindFirstChild("[Fire Armor] - $2623")
    if not fireArmor then return false end

    local remoteEvent = nil
    for _, obj in ipairs(fireArmor:GetChildren()) do
        if obj:IsA("RemoteEvent") then
            remoteEvent = obj
            break
        end
    end
    if not remoteEvent then
        for _, obj in ipairs(shop:GetDescendants()) do
            if obj:IsA("RemoteEvent") then
                remoteEvent = obj
                break
            end
        end
    end

    if remoteEvent then
        remoteEvent:FireServer()
        return true
    else
        local clickDetector = fireArmor:FindFirstChildOfClass("ClickDetector")
        if clickDetector then
            fireclickdetector(clickDetector)
            return true
        end
    end

    return false
end

-- Teleport function
local function teleportTo(cframe)
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = cframe
    end
end

-- Short wait function
local function waitSeconds(seconds)
    local start = tick()
    while tick() - start < seconds do
        RunService.Heartbeat:Wait()
    end
end

-- Auto Armor Monitor
local function startFireArmorMonitor()
    if FIREARMOR_MONITORING_TASK then return end
    FIREARMOR_MONITORING_TASK = task.spawn(function()
        while not LocalPlayer or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") do
            task.wait(0.05)
        end
        
        -- Wait a bit after character spawn to let inventory load properly
        task.wait(2)

        local fireArmorValue = nil
        while not fireArmorValue do
            local bodyEffects = Workspace:FindFirstChild("Players")
            if bodyEffects then
                local myEffects = bodyEffects:FindFirstChild(LocalPlayer.Name)
                if myEffects then
                    local effects = myEffects:FindFirstChild("BodyEffects")
                    if effects then
                        fireArmorValue = effects:FindFirstChild("FireArmor")
                    end
                end
            end
            task.wait(0.1)
        end

        local lastPurchase = 0
        while FIREARMOR_ENABLED do
            local currentArmorValue = fireArmorValue.Value
            local shouldBuy = false
            
            -- Check if player already has fire armor equipped
            local hasFireArmor = false
            
            -- Simple check: if armor value is above 0, assume we have fire armor
            if currentArmorValue > 0 then
                hasFireArmor = true
            end
            
            -- Additional check: look for fire armor tools
            if not hasFireArmor and LocalPlayer.Character then
                local backpack = LocalPlayer:FindFirstChild("Backpack")
                if backpack then
                    for _, tool in pairs(backpack:GetChildren()) do
                        if tool:IsA("Tool") and tool.Name:find("Fire") and tool.Name:find("Armor") then
                            hasFireArmor = true
                            break
                        end
                    end
                end
                
                if not hasFireArmor then
                    for _, tool in pairs(LocalPlayer.Character:GetChildren()) do
                        if tool:IsA("Tool") and tool.Name:find("Fire") and tool.Name:find("Armor") then
                            hasFireArmor = true
                            break
                        end
                    end
                end
            end
            
            -- Only buy if player doesn't already have fire armor and armor is completely gone
            if not hasFireArmor and currentArmorValue == 0 then
                shouldBuy = true
            end
            
            -- Execute purchase if conditions are met and cooldown has passed (3 second cooldown to prevent spam)
            if shouldBuy and tick() - lastPurchase > 3 then
                task.wait(0.05)
                
                -- Final check to make sure armor is still 0
                if fireArmorValue.Value == 0 then
                    lastPurchase = tick()
                    local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if rootPart then
                        local originalCFrame = rootPart.CFrame
                        teleportTo(shopCFrame)
                        waitSeconds(0.1)
                        buyFireArmor()
                        waitSeconds(0.1)
                        teleportTo(originalCFrame)
                        
                        -- Wait a bit after purchase to prevent rapid looping
                        task.wait(1)
                    end
                end
            end
            
            task.wait(0.05) -- Check every 0.05 seconds
        end

        FIREARMOR_MONITORING_TASK = nil
    end)
end

local function stopFireArmorMonitor()
    if FIREARMOR_MONITORING_TASK then
        task.cancel(FIREARMOR_MONITORING_TASK)
        FIREARMOR_MONITORING_TASK = nil
    end
end

-- Handle character respawn for fire armor monitoring
local respawnConnection = nil
local function setupRespawnHandling()
    if respawnConnection then
        respawnConnection:Disconnect()
    end
    
    respawnConnection = LocalPlayer.CharacterAdded:Connect(function()
        if FIREARMOR_ENABLED then
            -- Stop current monitoring and restart after respawn
            stopFireArmorMonitor()
            task.wait(1) -- Give time for character to fully load
            if FIREARMOR_ENABLED then -- Check if still enabled after wait
                startFireArmorMonitor()
            end
        end
    end)
end

Tab1:AddToggle('FireArmor', {
    Text = 'FireArmor',
    Default = false,
    Callback = function(state)
        FIREARMOR_ENABLED = state
        if state then
            setupRespawnHandling() -- Setup respawn handling
            startFireArmorMonitor()
        else
            stopFireArmorMonitor()
            if respawnConnection then
                respawnConnection:Disconnect()
                respawnConnection = nil
            end
        end
    end,
})

Tab1:AddToggle('AutoBlockToggle', {
    Text = 'Auto Block',
    Default = false,
    Callback = function(state)
        getgenv().autoBlockEnabled = state

        if getgenv().autoBlockConnection then
            getgenv().autoBlockConnection:Disconnect()
            getgenv().autoBlockConnection = nil
        end

        if state then
            getgenv().autoBlockConnection = game:GetService('RunService').Heartbeat
                :Connect(function()
                    local char = game.Players.LocalPlayer.Character
                    if not char then
                        return
                    end

                    game.ReplicatedStorage.MainEvent:FireServer('Block', true)

                    local hum = char:FindFirstChildOfClass('Humanoid')
                    if hum then
                        for _, anim in ipairs(hum:GetPlayingAnimationTracks()) do
                            if
                                anim.Animation.AnimationId:match('2788354405')
                            then
                                anim:Stop()
                            end
                        end
                    end

                    local effects = char:FindFirstChild('BodyEffects')
                    if effects and effects:FindFirstChild('Block') then
                        effects.Block:Destroy()
                    end
                end)
        end
    end,
})

Tab1:AddToggle('AntiSitToggle', {
    Text = 'Anti Sit',
    Default = false,
    Callback = function(state)
        getgenv().antiSitEnabled = state
        for _, seat in ipairs(workspace:GetDescendants()) do
            if seat:IsA('Seat') or seat:IsA('VehicleSeat') then
                seat.CanTouch = not state
            end
        end
        workspace.DescendantAdded:Connect(function(seat)
            if
                getgenv().antiSitEnabled
                and (seat:IsA('Seat') or seat:IsA('VehicleSeat'))
            then
                seat.CanTouch = false
            end
        end)
    end,
})

local anti_fling_toggle = Tab1:AddToggle('AntiFlingToggle', {
    Text = 'Anti Fling',
    Default = false,
})

-- Create dependency box for anti-fling strength
local anti_fling_depbox = Tab1:AddDependencyBox()
local anti_fling_strength = anti_fling_depbox:AddSlider('AntiFlingStrength', { 
    Text = 'Strength', 
    Min = 0.1, 
    Max = 10, 
    Default = 0.2, 
    Rounding = 1, 
    Suffix = "", 
    Compact = true 
})

-- Setup dependency - show strength slider only when anti-fling is enabled
anti_fling_depbox:SetupDependencies({
    { anti_fling_toggle, true }
})

-- Anti-fling callback with configurable strength
anti_fling_toggle:OnChanged(function(state)
        local rs = game:GetService("RunService")
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        
        if state then
            if _G.fling then 
                _G.fling:Disconnect() 
                _G.fling = nil
            end
            
            local function startAntiFling()
                local character = LocalPlayer.Character
                if not character then return end
                
                local hrp = character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end
                
                local last = hrp.Position
                
                _G.fling = rs.Heartbeat:Connect(function()
                    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        return
                    end
                    
                    local currentHrp = LocalPlayer.Character.HumanoidRootPart
                    local distance = (currentHrp.Position - last).Magnitude
                    
                -- Use configurable strength (lower = weaker, higher = stronger)
                local strength = anti_fling_strength and anti_fling_strength.Value or 1
                local threshold = 11 - strength  -- Invert the logic: higher strength = lower threshold
                
                if distance > threshold then
                        currentHrp.CFrame = CFrame.new(last)
                        currentHrp.Velocity = Vector3.zero
                        currentHrp.AssemblyLinearVelocity = Vector3.zero
                        currentHrp.AssemblyAngularVelocity = Vector3.zero
                        
                        for _, obj in pairs(currentHrp:GetChildren()) do
                            if obj:IsA("BodyVelocity") or obj:IsA("BodyAngularVelocity") or obj:IsA("BodyPosition") or obj:IsA("BodyThrust") or obj:IsA("BodyMover") then
                                obj:Destroy()
                            end
                        end
                        
                        for _, obj in pairs(LocalPlayer.Character:GetChildren()) do
                            if obj:IsA("BodyVelocity") or obj:IsA("BodyAngularVelocity") or obj:IsA("BodyPosition") or obj:IsA("BodyThrust") or obj:IsA("BodyMover") then
                                obj:Destroy()
                            end
                        end
                        
                        task.spawn(function()
                            for i = 1, 10 do
                                task.wait(0.01)
                                if currentHrp then
                                    currentHrp.CFrame = CFrame.new(last)
                                    currentHrp.Velocity = Vector3.zero
                                    currentHrp.AssemblyLinearVelocity = Vector3.zero
                                    currentHrp.AssemblyAngularVelocity = Vector3.zero
                                end
                            end
                        end)
                        
                        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                        if humanoid then
                            humanoid.PlatformStand = true
                            task.wait(0.1)
                            humanoid.PlatformStand = false
                        end
                    else
                        last = currentHrp.Position
                    end
                end)
            end
            
            startAntiFling()
            
            _G.characterAddedConnection = LocalPlayer.CharacterAdded:Connect(function()
                task.wait(1)
                startAntiFling()
            end)
            
        else
            if _G.fling then 
                _G.fling:Disconnect() 
                _G.fling = nil
            end
            if _G.characterAddedConnection then
                _G.characterAddedConnection:Disconnect()
                _G.characterAddedConnection = nil
            end
        end
end)

-- Misc02 Tab Content
local function findKeyButton()
    local shopFolder = workspace:FindFirstChild('Ignored')
    if shopFolder then
        local shop = shopFolder:FindFirstChild('Shop')
        if shop then
            for _, item in pairs(shop:GetChildren()) do
                -- More specific check: must contain [Key] and $137, but NOT LockPicker
                local itemName = item.Name:lower()
                if itemName:find('%[key%]') and itemName:find('$137') and not itemName:find('lockpicker') then
                    return item
                end
            end
        end
    end
    return nil
end

local function equipKey()
    local localPlayer = game.Players.LocalPlayer
    local character = localPlayer.Character
    local backpack = localPlayer:FindFirstChild('Backpack')
    
    if not character or not backpack then
        return nil
    end
    
    -- Look for key in backpack
    local key = backpack:FindFirstChild('[Key]')
    if not key then
        return nil
    end
    
    -- Equip the key
    local humanoid = character:FindFirstChild('Humanoid')
    if humanoid then
        humanoid:EquipTool(key)
        task.wait(0.1) -- Wait for equip to complete
        return key
    end
    
    return nil
end

local function useKey(key)
    if key and key:IsA('Tool') then
        key:Activate()
        task.wait(0.1)
        return true
    end
    return false
end

local function teleportToUnjailPositionAndBuyKey()
    local localPlayer = game.Players.LocalPlayer
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild('HumanoidRootPart') then
        api:notify('Character not found!', 3)
        return
    end
    
    -- Save original position
    local originalPosition = localPlayer.Character.HumanoidRootPart.CFrame
    
    -- Teleport to the specified unjail position
    local unjailPosition = Vector3.new(-270.74212646484375, 21.74802017211914, -241.5172119140625)
    localPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(unjailPosition)
    
    -- Wait a moment for teleport to complete
    task.wait(0.5)
    
    -- Find and buy the key
    local keyButton = findKeyButton()
    if keyButton then
        -- Find and click the key button
        local clickDetector = keyButton:FindFirstChild('ClickDetector') or keyButton:FindFirstChildWhichIsA('ClickDetector', true)
        if clickDetector then
            fireclickdetector(clickDetector)
            api:notify('Key purchased! Equipping and using...', 3)
            
            -- Wait for key to appear in backpack
            task.wait(1)
            
            -- Equip the key
            local key = equipKey()
            if key then
                api:notify('Key equipped! Using key...', 2)
                
                -- Use the key
                if useKey(key) then
                    api:notify('Unjail complete! Key used successfully!', 3)
                else
                    api:notify('Key equipped but failed to use!', 3)
                end
            else
                api:notify('Key purchased but failed to equip!', 3)
            end
        else
            api:notify('Teleported but could not find ClickDetector!', 3)
        end
    else
        api:notify('Teleported but key button not found!', 3)
    end
end

Tab2:AddButton({
    Text = 'Unjail',
    Func = function()
        teleportToUnjailPositionAndBuyKey()
    end,
    DoubleClick = false,
})

Tab2:AddButton({
    Text = 'AntiLag',
    Func = function()
        for _, player in ipairs(game.Players:GetPlayers()) do
            if player.Character then
                pcall(function()
                    for _, accessory in ipairs(player.Character:GetChildren()) do
                        if accessory:IsA("Accessory") then
                            accessory:Destroy()
                        end
                    end
                    
                    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        for _, clothing in ipairs(humanoid:GetChildren()) do
                            if clothing:IsA("Clothing") or clothing:IsA("Shirt") or clothing:IsA("Pants") or clothing:IsA("ShirtGraphic") then
                                clothing:Destroy()
                            end
                        end
                    end
                    for _, clothing in ipairs(player.Character:GetChildren()) do
                        if clothing:IsA("Clothing") or clothing:IsA("Shirt") or clothing:IsA("Pants") or clothing:IsA("ShirtGraphic") then
                            clothing:Destroy()
                        end
                    end
                end)
            end
        end
    end,
    DoubleClick = false,
})

local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local TweenService = game:GetService('TweenService')
local LocalPlayer = Players.LocalPlayer

local cashierFolder = workspace:FindFirstChild('Cashiers')
local dropFolder = workspace:FindFirstChild('Ignored')
    and workspace.Ignored:FindFirstChild('Drop')
local attackRadius = 15

local farming = false
local currentCharacter = LocalPlayer.Character
    or LocalPlayer.CharacterAdded:Wait()
local healthConnection = nil
local attackThread = nil
local farmingThread = nil
local noclipConnection = nil
local antiAFKConnection = nil
local antiSitConnection = nil

LocalPlayer.CharacterAdded:Connect(function(char)
    currentCharacter = char
    if farming then
        task.wait(5)
        startFarming()
        monitorHealth(true)
    end
end)

function monitorHealth(enable)
    local humanoid = currentCharacter:WaitForChild('Humanoid', 5)
    if not humanoid then
        return
    end

    if healthConnection then
        healthConnection:Disconnect()
        healthConnection = nil
    end

    if enable then
        healthConnection = humanoid.HealthChanged:Connect(function(newHealth)
            if newHealth < 3 then
                if currentCharacter then
                    currentCharacter:BreakJoints()
                end
                if humanoid and humanoid.Health > 0 then
                    humanoid.Health = 0
                end
                task.delay(0.5, function()
                    if humanoid and humanoid.Health > 0 then
                        humanoid:Destroy()
                    end
                end)
            end
        end)
    end
end

local function equipCombat()
    if not currentCharacter then
        return
    end
    local backpack = LocalPlayer:FindFirstChild('Backpack')
    if not backpack then
        return
    end

    local tool = currentCharacter:FindFirstChild('Combat')
        or backpack:FindFirstChild('Combat')
    if not tool then
        return
    end
    if currentCharacter:FindFirstChild('Combat') == nil then
        LocalPlayer.Character.Humanoid:EquipTool(tool)
    end
end

local function autoAttack()
    if attackThread then
        return
    end
    attackThread = task.spawn(function()
        while
            farming
            and currentCharacter
            and currentCharacter:FindFirstChild('Humanoid')
        do
            local combatTool = currentCharacter:FindFirstChild('Combat')
            if combatTool then
                combatTool:Activate()
            else
                equipCombat()
            end
            task.wait(1)
        end
        attackThread = nil
    end)
end

local function setNoClip(enabled)
    if enabled then
        noclipConnection = RunService.Stepped:Connect(function()
            if currentCharacter then
                for _, part in pairs(currentCharacter:GetChildren()) do
                    if part:IsA('BasePart') then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
        if currentCharacter then
            for _, part in pairs(currentCharacter:GetChildren()) do
                if part:IsA('BasePart') then
                    part.CanCollide = true
                end
            end
        end
    end
end

local function startAntiAFK()
    if antiAFKConnection then
        antiAFKConnection:Disconnect()
        antiAFKConnection = nil
    end
    
    antiAFKConnection = RunService.Heartbeat:Connect(function()
        if not farming then
            return
        end
        
        local character = LocalPlayer.Character
        if character and character:FindFirstChild('Humanoid') then
            local humanoid = character.Humanoid
            humanoid:Move(Vector3.new(math.random(-1, 1), 0, math.random(-1, 1)))
        end
    end)
end

local function startAntiSit()
    if antiSitConnection then
        antiSitConnection:Disconnect()
        antiSitConnection = nil
    end
    
    for _, seat in ipairs(workspace:GetDescendants()) do
        if seat:IsA('Seat') or seat:IsA('VehicleSeat') then
            seat.CanTouch = false
        end
    end
    
    antiSitConnection = workspace.DescendantAdded:Connect(function(seat)
        if farming and (seat:IsA('Seat') or seat:IsA('VehicleSeat')) then
            seat.CanTouch = false
        end
    end)
end

local function stopAntiAFK()
    if antiAFKConnection then
        antiAFKConnection:Disconnect()
        antiAFKConnection = nil
    end
end

local function stopAntiSit()
    if antiSitConnection then
        antiSitConnection:Disconnect()
        antiSitConnection = nil
    end
    
    for _, seat in ipairs(workspace:GetDescendants()) do
        if seat:IsA('Seat') or seat:IsA('VehicleSeat') then
            seat.CanTouch = true
        end
    end
end

local function tweenToPosition(position, duration)
    if
        currentCharacter
        and currentCharacter:FindFirstChild('HumanoidRootPart')
    then
        local hrp = currentCharacter.HumanoidRootPart
        local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear)
        local tween = TweenService:Create(
            hrp,
            tweenInfo,
            { CFrame = CFrame.new(position) }
        )
        tween:Play()
        tween.Completed:Wait()
    end
end

local function tpInsideModelTween(model)
    local rootPart = model.PrimaryPart
        or model:FindFirstChildWhichIsA('BasePart', true)
    if not rootPart then
        return
    end
    local targetPos = rootPart.Position
    tweenToPosition(targetPos, 0.4)
end

local function collectDrops()
    if
        not dropFolder
        or not currentCharacter
        or not currentCharacter:FindFirstChild('HumanoidRootPart')
    then
        return
    end
    
    local hrp = currentCharacter.HumanoidRootPart
    local hrpPos = hrp.Position
    
    for _, drop in ipairs(dropFolder:GetChildren()) do
        if drop:IsA('BasePart') then
            local dist = (drop.Position - hrpPos).Magnitude
            if dist <= attackRadius then
                local clickDetector = drop:FindFirstChildWhichIsA('ClickDetector', true)
                if clickDetector then
                    fireclickdetector(clickDetector)
                    task.wait(0.5)
                end
            end
        end
    end
end

function startFarming()
    if farmingThread then
        return
    end
    
    startAntiAFK()
    startAntiSit()
    
    farmingThread = task.spawn(function()
        setNoClip(true)
        while farming do
            if not cashierFolder then
                break
            end
            local cashiers = cashierFolder:GetChildren()
            for i = 1, #cashiers do
                if not farming then
                    break
                end
                local cashier = cashiers[i]
                if cashier.Name == 'CA$HIER' then
                    local humanoid =
                        cashier:FindFirstChildWhichIsA('Humanoid', true)
                    if humanoid and humanoid.Health > 0 then
                        if not cashier.PrimaryPart then
                            local firstPart =
                                cashier:FindFirstChildWhichIsA('BasePart', true)
                            if firstPart then
                                cashier.PrimaryPart = firstPart
                            else
                                continue
                            end
                        end

                        equipCombat()
                        tpInsideModelTween(cashier)
                        autoAttack()
                        
                        local punchCount = 0
                        local maxPunches = 10
                        local originalHealth = humanoid.Health
                        local atmDefeated = false
                        
                        while farming and humanoid.Health > 0 do
                            collectDrops()
                            tpInsideModelTween(cashier)
                            
                            if humanoid.Health >= originalHealth then
                                punchCount = punchCount + 1
                                if punchCount > maxPunches then
                                    break
                                end
                            else
                                punchCount = 0
                                originalHealth = humanoid.Health
                            end
                        end
                        
                        if humanoid.Health <= 0 then
                            atmDefeated = true
                        end
                        
                        if atmDefeated then
                            local dropsRemain = true
                            local collectionAttempts = 0
                            local maxCollectionAttempts = 50
                            
                            while farming and dropsRemain and collectionAttempts < maxCollectionAttempts do
                                dropsRemain = false
                                collectionAttempts = collectionAttempts + 1
                                
                                if
                                    dropFolder
                                    and currentCharacter
                                    and currentCharacter:FindFirstChild(
                                        'HumanoidRootPart'
                                    )
                                then
                                    local hrp = currentCharacter.HumanoidRootPart
                                    local hrpPos = hrp.Position
                                    
                                    for _, drop in ipairs(dropFolder:GetChildren()) do
                                        if drop:IsA('BasePart') then
                                            local dist = (drop.Position - hrpPos).Magnitude
                                            if dist <= attackRadius then
                                                dropsRemain = true
                                                break
                                            end
                                        end
                                    end
                                end
                                
                                if dropsRemain then
                                    collectDrops()
                                    tpInsideModelTween(cashier)
                                    task.wait(0.3)
                                end
                            end
                        end

                        task.wait(1)
                    end
                end
            end
            task.wait(1)
        end
        setNoClip(false)
        farmingThread = nil
        attackThread = nil
    end)
end

function stopFarming()
    farming = false
    farmingThread = nil
    attackThread = nil
    setNoClip(false)
    
    stopAntiAFK()
    stopAntiSit()
end


Tab3:AddToggle('cashatmfarm', {
    Text = 'ATM Farm',
    Default = false,
    Callback = function(Value)
        Toggles.AutoStompFarm:SetValue(false)

        if Value then
            farming = true
            monitorHealth(true)
            startFarming()
        else
            stopFarming()
            monitorHealth(false)
        end
    end,
})

local Players = game:GetService('Players')
local Workspace = game:GetService('Workspace')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local RunService = game:GetService('RunService')

local LocalPlayer = Players.LocalPlayer
local Backpack = LocalPlayer:WaitForChild('Backpack')

local AutoStompPos = CFrame.new(-1123, 21.75, -217.5)
local Event = ReplicatedStorage:WaitForChild('MainEvent')

local farmEnabled = false
local stompTask
local originalStompPosition = nil

local function Teleport(pos)
    local char = LocalPlayer.Character
    if char and char:FindFirstChild('HumanoidRootPart') then
        char.HumanoidRootPart.CFrame = pos
    end
end

local function GetPlayerPositionForTeleport(character)
    local root = character:FindFirstChild('HumanoidRootPart')
    if not root then
        return nil
    end
    local parts = {}
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA('BasePart') then
            table.insert(parts, part.Position)
        end
    end
    if #parts == 0 then
        return root.CFrame + Vector3.new(0, 3, 0)
    end
    local sum = Vector3.new(0, 0, 0)
    for _, pos in ipairs(parts) do
        sum = sum + pos
    end
    local avgPos = sum / #parts
    return CFrame.new(avgPos + Vector3.new(0, 3, 0))
end

local function GetValidTargets()
    local targets = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local humanoid = player.Character:FindFirstChildOfClass('Humanoid')
            local root = player.Character:FindFirstChild('HumanoidRootPart')
            if
                humanoid
                and root
                and humanoid.Health <= 2
                and humanoid.Health > 0
            then
                table.insert(targets, root)
            end
        end
    end
    return targets
end

local function StartStompFarm()
    stompTask = task.spawn(function()
        while farmEnabled do
            local targets = GetValidTargets()
            for _, targetRoot in pairs(targets) do
                if not farmEnabled then
                    break
                end
                local teleportPos =
                    GetPlayerPositionForTeleport(targetRoot.Parent)
                if teleportPos then
                    Teleport(teleportPos)
                else
                    Teleport(targetRoot.CFrame + Vector3.new(0, 3, 0))
                end
                task.wait(0.2)
                Event:FireServer('Stomp')
                task.wait(0.1)
                Teleport(AutoStompPos)
                task.wait(0.2)
            end
            task.wait(0.5)
        end
    end)
end

local function StopStompFarm()
    farmEnabled = false
    if stompTask then
        task.cancel(stompTask)
        stompTask = nil
    end
    
    if originalStompPosition then
        Teleport(originalStompPosition)
        originalStompPosition = nil
    end
end

local function OnCharacterAdded(char)
    char:WaitForChild('HumanoidRootPart')
    if farmEnabled then
        Teleport(AutoStompPos)
    end
end

LocalPlayer.CharacterAdded:Connect(OnCharacterAdded)

Tab3:AddToggle('AutoStompFarm', {
    Text = 'Stomp Farm',
    Default = false,
    Callback = function(Value)
        farmEnabled = Value
        if farmEnabled then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
                originalStompPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
            end
            
            if
                not (
                    LocalPlayer.Character
                    and LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
                )
            then
                LocalPlayer.CharacterAdded:Wait()
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
                    originalStompPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
                end
            end
            Teleport(AutoStompPos)
            StartStompFarm()
        else
            StopStompFarm()
        end
    end,
})

do
    local Players = game:GetService('Players')
    local RunService = game:GetService('RunService')
    local player = Players.LocalPlayer
    local targetPos = Vector3.new(-279.602, 22.568, -1142.230)
    local toolName = 'Combat'
    local toggleEnabled = false
    local heartbeatConn
    local charAddedConn
    local activateLoopRunning = false
    local activateLoopCancel = false
    local originalPos = nil
    local targetPart =
        workspace.MAP.Map['Punching(BAGS)']:GetChildren()[3]['pretty ransom']

    local function equipTool(character)
        if not character then
            return nil
        end
        local backpack = player:WaitForChild('Backpack')
        local humanoid = character:FindFirstChildOfClass('Humanoid')
        if not humanoid then
            return nil
        end
        local tool = backpack:FindFirstChild(toolName)
            or character:FindFirstChild(toolName)
        if tool then
            if character:FindFirstChild(toolName) ~= tool then
                humanoid:EquipTool(tool)
                task.wait(0.01)
            end
            return tool
        end
        return nil
    end

    local function unequipTools(character)
        if not character then
            return
        end
        local humanoid = character:FindFirstChildOfClass('Humanoid')
        if humanoid then
            humanoid:UnequipTools()
        end
    end

    local function teleportAndFacePart(character, part)
        local hrp = character:FindFirstChild('HumanoidRootPart')
        if hrp and part then
            local bagPosition = part.Position
            hrp.CFrame = CFrame.new(bagPosition + Vector3.new(0, 2, 0), bagPosition + Vector3.new(0, 0, 1))
        end
    end

    local function activateToolLoop(tool)
        activateLoopRunning = true
        activateLoopCancel = false
        local humanoid = player.Character
            and player.Character:FindFirstChildOfClass('Humanoid')
        while
            toggleEnabled
            and tool
            and tool.Parent
            and not activateLoopCancel
            and humanoid
        do
            if
                player.Character
                and player.Character:FindFirstChild(toolName) ~= tool
            then
                humanoid:EquipTool(tool)
                task.wait(0.01)
            end
            if tool.Activate then
                tool:Activate()
            end
            task.wait(0.01)
            humanoid:UnequipTools()
            task.wait(0.01)
            humanoid:EquipTool(tool)
            task.wait(0.01)
        end
        activateLoopRunning = false
    end

    local function stopAll()
        toggleEnabled = false
        activateLoopCancel = true
        if heartbeatConn then
            heartbeatConn:Disconnect()
            heartbeatConn = nil
        end
        if charAddedConn then
            charAddedConn:Disconnect()
            charAddedConn = nil
        end
        local character = player.Character
        if character and character.Parent then
            local hrp = character:FindFirstChild('HumanoidRootPart')
            if hrp and originalPos then
                hrp.CFrame = originalPos
            end
            unequipTools(character)
        end
        originalPos = nil
    end

    local function onToggleChanged(value)
        if value == toggleEnabled then
            return
        end
        toggleEnabled = value
        if not toggleEnabled then
            stopAll()
            return
        end
        local character = player.Character
        if character and character.Parent then
            local hrp = character:FindFirstChild('HumanoidRootPart')
            if hrp then
                originalPos = hrp.CFrame
            end
        end
        activateLoopCancel = false
        heartbeatConn = RunService.Heartbeat:Connect(function()
            if not toggleEnabled then
                return
            end
            local character = player.Character
            if not character or not character.Parent then
                return
            end
            teleportAndFacePart(character, targetPart)
            local tool = equipTool(character)
            local humanoid = character:FindFirstChildOfClass('Humanoid')
            if humanoid and humanoid.Health < 2 then
                humanoid.Health = 0
            end
            if tool and not activateLoopRunning then
                task.spawn(function()
                    activateToolLoop(tool)
                end)
            end
        end)
        charAddedConn = player.CharacterAdded:Connect(function(char)
            if toggleEnabled then
                task.wait(0.01)
                teleportAndFacePart(char, targetPart)
                equipTool(char)
            end
        end)
    end

    Tab3:AddToggle('BoxingFarm', {
        Text = 'Boxing Farm',
        Default = false,
        Callback = function(value)
            onToggleChanged(value)
        end,
    })
end

local originalLettucePosition = nil

Tab3:AddToggle('lettuceToggle', {
    Text = 'Auto Lettuce',
    Default = false,
    Callback = function(value)
        if value then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
                originalLettucePosition = LocalPlayer.Character.HumanoidRootPart.CFrame
            end
        else
            if originalLettucePosition then
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
                    LocalPlayer.Character.HumanoidRootPart.CFrame = originalLettucePosition
                end
                originalLettucePosition = nil
            end
        end
    end,
})

local function fireClickDetector(cd)
    if cd and cd:IsA('ClickDetector') then
        fireclickdetector(cd)
    end
end

local function equipLettuce()
    local tool = LocalPlayer.Backpack:FindFirstChild('[Lettuce]')
    if tool then
        tool.Parent = LocalPlayer.Character
        return tool
    end
    return nil
end

local function activateLettuce()
    local tool = LocalPlayer.Character
        and LocalPlayer.Character:FindFirstChild('[Lettuce]')
    if tool and tool:IsA('Tool') then
        tool:Activate()
        return true
    end
    return false
end

local function buyLettuce()
    LocalPlayer.Character:PivotTo(CFrame.new(-86.74, 23.32, -632.27))
    task.wait(0.05)
    local shop = Workspace:FindFirstChild('Ignored')
        and Workspace.Ignored:FindFirstChild('Shop')
    if shop then
        for _, obj in ipairs(shop:GetDescendants()) do
            if
                obj:IsA('ClickDetector')
                and obj.Parent
                and obj.Parent.Name == '[Lettuce] - $5'
            then
                fireClickDetector(obj)
                break
            end
        end
    end
    task.wait(0.1)
end

task.spawn(function()
    while true do
        if Toggles.lettuceToggle.Value then
            local hasLettuce = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('[Lettuce]')
            
            if not hasLettuce then
                buyLettuce()
                equipLettuce()
            end
            
            local activated = activateLettuce()
            
            if not activated then
                task.wait(0.05)
                buyLettuce()
                equipLettuce()
            end
        end
        task.wait(0.05)
    end
end)

local toggleName = 'HeavyWeightsAuto'

Tab3:AddToggle(toggleName, {
    Text = 'Auto Weights',
    Default = false,
})

local activationConnection
local respawnConnection
local toolMonitorConnection
local originalWeightPosition = nil

local function getCharacter()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = char:WaitForChild('HumanoidRootPart')
    return char, hrp
end

local function teleportTo(pos)
    local _, hrp = getCharacter()
    hrp.CFrame = CFrame.new(pos)
    task.wait(0.5)
end

local function findShopItem()
    local shopFolder = Workspace.Ignored.Shop
    for _, item in ipairs(shopFolder:GetChildren()) do
        if item.Name:lower():find('heavyweights') then
            return item
        end
    end
    return nil
end

local function fireClickDetector(shopItem)
    if not shopItem then
        return
    end
    local clickDetector = nil
    if shopItem:IsA('ClickDetector') then
        clickDetector = shopItem
    else
        clickDetector = shopItem:FindFirstChild('ClickDetector')
            or shopItem:FindFirstChildWhichIsA('ClickDetector', true)
    end
    if clickDetector and clickDetector:IsA('ClickDetector') then
        pcall(function()
            fireclickdetector(clickDetector)
        end)
    end
end

local function equipTool(toolName)
    local character = LocalPlayer.Character
    if character then
        local equippedTool = character:FindFirstChild(toolName)
        if equippedTool and equippedTool:IsA('Tool') then
            return equippedTool
        end
    end
    
    for i = 1, 50 do
        local tool = Backpack:FindFirstChild(toolName)
        if tool and tool:IsA('Tool') then
            local humanoid = character and character:FindFirstChild('Humanoid')
            if humanoid then
                humanoid:EquipTool(tool)
                task.wait(0.1)
                return tool
            end
        end
        task.wait(0.05)
    end
    return nil
end

local function autoActivateTool(tool)
    if activationConnection then
        activationConnection:Disconnect()
        activationConnection = nil
    end
    activationConnection = RunService.Heartbeat:Connect(function()
        if not Toggles[toggleName].Value then
            return
        end
        
        local character = LocalPlayer.Character
        if not character then
            return
        end
        
        local humanoid = character:FindFirstChild('Humanoid')
        if not humanoid then
            return
        end
        
        local equippedTool = character:FindFirstChild('[HeavyWeights]')
        if not equippedTool then
            local backpackTool = Backpack:FindFirstChild('[HeavyWeights]')
            if backpackTool then
                humanoid:EquipTool(backpackTool)
                tool = backpackTool
            end
        else
            tool = equippedTool
        end
        
        if tool and tool.Parent == character then
            pcall(function()
                tool:Activate()
            end)
        end
    end)
end

local function mainProcess()
    teleportTo(Vector3.new(-46.36, 23.57, -653.74))
    local shopItem = findShopItem()
    if not shopItem then
        return
    end
    fireClickDetector(shopItem)
    task.wait(0.5)
    teleportTo(Vector3.new(768.47, 112.62, -787.92))
    
    local tool = equipTool('[HeavyWeights]')
    if tool then
        autoActivateTool(tool)
    else
        task.wait(0.5)
        tool = equipTool('[HeavyWeights]')
        if tool then
            autoActivateTool(tool)
        end
    end
end

local function onToggleChanged(value)
    if not value then
        if activationConnection then
            activationConnection:Disconnect()
            activationConnection = nil
        end
        if respawnConnection then
            respawnConnection:Disconnect()
            respawnConnection = nil
        end
        if toolMonitorConnection then
            toolMonitorConnection:Disconnect()
            toolMonitorConnection = nil
        end
        
        if originalWeightPosition then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
                LocalPlayer.Character.HumanoidRootPart.CFrame = originalWeightPosition
            end
            originalWeightPosition = nil
        end
        return
    end
    
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        originalWeightPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
    end
    
    if toolMonitorConnection then
        toolMonitorConnection:Disconnect()
        toolMonitorConnection = nil
    end
    
    toolMonitorConnection = RunService.Heartbeat:Connect(function()
        if not Toggles[toggleName].Value then
            return
        end
        
        local character = LocalPlayer.Character
        if not character then
            return
        end
        
        local humanoid = character:FindFirstChild('Humanoid')
        if not humanoid then
            return
        end
        
        local equippedTool = character:FindFirstChild('[HeavyWeights]')
        if not equippedTool then
            local backpackTool = Backpack:FindFirstChild('[HeavyWeights]')
            if backpackTool then
                humanoid:EquipTool(backpackTool)
            end
        end
    end)
    
    task.spawn(mainProcess)
    if respawnConnection then
        respawnConnection:Disconnect()
        respawnConnection = nil
    end
    respawnConnection = LocalPlayer.CharacterAdded:Connect(function()
        task.wait(2)
        if Toggles[toggleName].Value then
            task.spawn(mainProcess)
        end
    end)
end

Toggles[toggleName]:OnChanged(onToggleChanged)

local playerListTabBox = tabs.lua:AddLeftTabbox()
local playerListTab = playerListTabBox:AddTab('fund01')
local strafesTab = playerListTabBox:AddTab('fund02')
local addonsTab = playerListTabBox:AddTab('fund03')

local function getAllPlayers()
    local players = {}
    for _, player in pairs(game.Players:GetPlayers()) do
        table.insert(players, {
            username = player.Name,
            displayName = player.DisplayName
        })
    end
    return players
end

local playerDropdown = playerListTab:AddDropdown('player_dropdown', {
    Values = {},
    Default = 1,
    Multi = false,
    Text = 'Select Player',
    Tooltip = 'Choose a player from the list',
    Callback = function(value)
    end,
})

local function updatePlayerDropdown()
    local players = getAllPlayers()
    local playerNames = {}
    for _, player in ipairs(players) do
        table.insert(playerNames, player.username)
    end
    playerDropdown:SetValues(playerNames)
end

updatePlayerDropdown()

game.Players.PlayerAdded:Connect(function()
    task.wait(0.1)
    updatePlayerDropdown()
end)

game.Players.PlayerRemoving:Connect(function()
    updatePlayerDropdown()
end)

local liveNote = playerListTab:AddLabel('result: ?', true)
liveNote.Name = 'live_note'

local lastValidMatch = nil

local searchInput = playerListTab:AddInput('player_search', {
    Text = 'player search',
    Tooltip = '$$$SUDO APT OPSEC',
    Placeholder = '',
    Callback = function(value)
        local players = getAllPlayers()
        
        if value == '' then
            liveNote:SetText('result: ?')
            lastValidMatch = nil
            return
        end
        
        local searchTerm = value:lower()
        local closestMatch = nil
        local closestDistance = math.huge
        
        local exactMatches = {}
        local containsMatches = {}
        
        for _, player in ipairs(players) do
            local username = player.username:lower()
            local displayName = player.displayName:lower()
            
            if username:sub(1, #searchTerm) == searchTerm or displayName:sub(1, #searchTerm) == searchTerm then
                table.insert(exactMatches, player)
            elseif username:find(searchTerm, 1, true) or displayName:find(searchTerm, 1, true) then
                table.insert(containsMatches, player)
            end
        end
        
        if #exactMatches > 0 then
            for _, player in ipairs(exactMatches) do
                local username = player.username:lower()
                local displayName = player.displayName:lower()
                
                local usernameMatch = username:find(searchTerm, 1, true)
                local displayNameMatch = displayName:find(searchTerm, 1, true)
                
                local distance = math.huge
                if usernameMatch then
                    distance = math.min(distance, usernameMatch - 1)
                end
                if displayNameMatch then
                    distance = math.min(distance, displayNameMatch - 1)
                end
                
                if distance < closestDistance then
                    closestDistance = distance
                    closestMatch = player
                end
            end
        elseif #containsMatches > 0 then
            closestMatch = containsMatches[1]
        end
        
        if closestMatch then
            lastValidMatch = closestMatch
            
            local displayUsername = closestMatch.username
            liveNote:SetText('result: ' .. displayUsername .. ' (' .. closestMatch.displayName .. ')')
            
            local playerNames = {}
            for _, player in ipairs(players) do
                table.insert(playerNames, player.username)
            end
            
            playerDropdown:SetValues(playerNames)
            
            for i, name in ipairs(playerNames) do
                if name == closestMatch.username then
                    task.wait(0.01)
                    playerDropdown:SetValue(i)
                    task.wait(0.01)
                    playerDropdown:SetValue(closestMatch.username)
                    break
                end
            end
        else
            if lastValidMatch then
                local displayUsername = lastValidMatch.username
                liveNote:SetText('result: ' .. displayUsername .. ' (' .. lastValidMatch.displayName .. ')')
            else
                liveNote:SetText('result: ')
            end
        end
    end,
})

local function KnockCheck(player)
    if player and player.Character then
        local bodyEffects = player.Character:FindFirstChild("BodyEffects")
        if bodyEffects then
            local knockOut = bodyEffects:FindFirstChild("K.O")
            return knockOut and knockOut.Value == true
        end
    end

    return false
end

local function isPlayerDead(player)
    if player and player.Character then
        local bodyEffects = player.Character:FindFirstChild("BodyEffects")
        if bodyEffects then
            local deathEffect = bodyEffects:FindFirstChild("SDeath")
            return deathEffect and deathEffect.Value == true
        end
    end
    return false
end

local function checkStompSuccess(player, originalHealth)
    if not player or not player.Character then
        return false
    end
    
    local bodyEffects = player.Character:FindFirstChild("BodyEffects")
    if not bodyEffects then
        return false
    end
    
    local healthEffect = bodyEffects:FindFirstChild("Health")
    local currentHealth = healthEffect and healthEffect.Value or 0
    
    local isDead = isPlayerDead(player)
    local stillKnocked = KnockCheck(player)
    
    -- More detailed debug info
    local healthDiff = originalHealth - currentHealth
    api:notify(string.format("Health: %.1f -> %.1f (Diff: %.1f, Dead: %s, Knocked: %s)", originalHealth, currentHealth, healthDiff, tostring(isDead), tostring(stillKnocked)), 3)
    
    -- Try multiple verification methods
    local healthDecreased = healthDiff > 0.5  -- Lower threshold
    local healthZero = currentHealth <= 0
    local significantDamage = healthDiff > 5.0  -- Significant damage
    
    -- Check if target is no longer knocked (might indicate stomp hit)
    local wasKnockedBefore = true  -- We assume they were knocked since we're stomping
    local noLongerKnocked = wasKnockedBefore and not stillKnocked
    
    local success = isDead or healthDecreased or healthZero or significantDamage or noLongerKnocked
    
    api:notify(string.format("Verification: Damage=%.1f, Dead=%s, Success=%s", healthDiff, tostring(isDead), tostring(success)), 2)
    
    return success
end

local stickyAimEnabled = false
local stickyAimTarget = nil
local originalNamecall = nil
local stickyAimActive = false

local knockSequenceActive = false
local savedOriginalPosition = nil

local function hasForcefield(player)
    if player and player.Character then
        local forcefield = player.Character:FindFirstChild("ForceField")
        return forcefield ~= nil
    end
    return false
end

local function enableStickySilentAim(targetPlayer)
    if not targetPlayer then return end
    
    stickyAimEnabled = true
    stickyAimTarget = targetPlayer
    
    if not originalNamecall then
        pcall(function()
            originalNamecall = getrawmetatable(game).__namecall
            
            getrawmetatable(game).__namecall = function(self, ...)
            local args = {...}
            local method = getnamecallmethod()
            
            if stickyAimEnabled and stickyAimTarget and stickyAimTarget.Character and stickyAimActive then
                if method == "FireServer" and self == MainEvent and args[1] == "ShootGun" then
                    if hasForcefield(stickyAimTarget) then
                    else
                        local targetHead = stickyAimTarget.Character:FindFirstChild("Head")
                        if targetHead then
                            args[4] = targetHead.Position
                            args[5] = targetHead
                        end
                    end
                end
            end
            
            return originalNamecall(self, ...)
        end
        end)
    end
end

local function disableStickySilentAim()
    stickyAimEnabled = false
    stickyAimTarget = nil
    stickyAimActive = false
end

local MainEvent = nil
if game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent") then
    MainEvent = game:GetService("ReplicatedStorage").MainEvent
elseif game:GetService("ReplicatedStorage"):FindFirstChild("MAINEVENT") then
    MainEvent = game:GetService("ReplicatedStorage").MAINEVENT
elseif game:GetService("ReplicatedStorage"):WaitForChild("MainRemotes"):WaitForChild("MainRemoteEvent") then
    MainEvent = game:GetService("ReplicatedStorage"):WaitForChild("MainRemotes"):WaitForChild("MainRemoteEvent")
else
end

local teleportButton = playerListTab:AddButton({
    Text = 'Teleport',
    Func = function()
        local selectedPlayer = playerDropdown.Value
        if selectedPlayer and selectedPlayer ~= '' then
            local targetPlayer = game.Players:FindFirstChild(selectedPlayer)
            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild('HumanoidRootPart') then
                local localPlayer = game.Players.LocalPlayer
                if localPlayer.Character and localPlayer.Character:FindFirstChild('HumanoidRootPart') then
                    local targetPosition = targetPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 5, 0)
                    localPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
                end
            end
        end
    end,
    DoubleClick = false,
    Tooltip = 'Teleport you to the selected target.',
})

local function proceedWithKnock(Target, selectedPlayer, localPlayer, humanoidRootPart, originalCFrame)
    local targetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
    local targetHead = Target.Character:FindFirstChild("Head")
    
    if targetHead and targetHRP then
        enableStickySilentAim(Target)
        
        local targetHeadPos = targetHead.Position
        local stickToHeadPos = Vector3.new(targetHeadPos.X, targetHeadPos.Y + 5, targetHeadPos.Z)
        humanoidRootPart.CFrame = CFrame.new(stickToHeadPos)
        
        task.spawn(function()
            while Target and Target.Character and not KnockCheck(Target) do
                if not game.Players:FindFirstChild(selectedPlayer) then
                    api:notify(selectedPlayer .. " left the game", 5)
                    updatePlayerDropdown()
                    disableStickySilentAim()
                    return
                end
                
                if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    break
                end
                
                local currentTool = localPlayer.Character:FindFirstChildOfClass("Tool")
                if not currentTool or not currentTool:FindFirstChild("Handle") then
                    break
                end
                
                local currentTargetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
                local currentTargetHead = Target.Character:FindFirstChild("Head")
                
                if currentTargetHRP and currentTargetHead then
                    local targetHeadPos = currentTargetHead.Position
                    local stickToHeadPos = Vector3.new(targetHeadPos.X, targetHeadPos.Y + 5, targetHeadPos.Z)
                    
                    humanoidRootPart.CFrame = CFrame.new(stickToHeadPos)
                    humanoidRootPart.Position = stickToHeadPos
                    
                    if hasForcefield(Target) then
                        task.wait(0.1)
                    else
                        for i = 1, 3 do
                            if Target and Target.Character and not KnockCheck(Target) and not hasForcefield(Target) then
                                humanoidRootPart.CFrame = CFrame.new(stickToHeadPos)
                                humanoidRootPart.Position = stickToHeadPos
                                
                                stickyAimActive = true
                                MainEvent:FireServer("ShootGun", currentTool.Handle, currentTool.Handle.Position, currentTargetHead.Position, currentTargetHead, Vector3.new(0, 1, 0))
                                task.wait(0.01)
                                stickyAimActive = false
                                task.wait(0.05)
                            else
                                if hasForcefield(Target) then
                                end
                                break
                            end
                        end
                    end
                else
                    break
                end
                
                task.wait(0.01)
            end
            
            if Target and Target.Character and KnockCheck(Target) then
            else
            end
            
            disableStickySilentAim()
            
            if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                localPlayer.Character.HumanoidRootPart.CFrame = originalCFrame
            end
        end)
    end
end

local teleportSubButton = teleportButton:AddButton({
    Text = 'Knock',
    Func = function()
        local selectedPlayer = playerDropdown.Value
        if selectedPlayer and selectedPlayer ~= '' then
            local Target = game.Players:FindFirstChild(selectedPlayer)
            local localPlayer = game.Players.LocalPlayer
            
            if Target and Target.Character and localPlayer.Character then
                local originalCFrame = localPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame
                local humanoidRootPart = localPlayer.Character:FindFirstChild("HumanoidRootPart")
                local Tool = localPlayer.Character:FindFirstChildOfClass("Tool")
                
                if humanoidRootPart and Tool and Tool:FindFirstChild("Handle") then
                    local targetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
                    local targetHead = Target.Character:FindFirstChild("Head")
                    
                    if targetHead and targetHRP then
                        if KnockCheck(Target) then
                            api:notify(selectedPlayer .. " is already knocked.", 2)
                            return
                        end
                        
                        if hasForcefield(Target) then
                            api:notify(selectedPlayer .. " is in an active protective barrier. Waiting...", 10)
                            
                            task.spawn(function()
                                while hasForcefield(Target) and Target and Target.Character do
                                    if not game.Players:FindFirstChild(selectedPlayer) then
                                        api:notify(selectedPlayer .. " left the game", 5)
                                        updatePlayerDropdown()
                                        return
                                    end
                                    task.wait(0.1)
                                end
                                
                                if Target and Target.Character then
                                    proceedWithKnock(Target, selectedPlayer, localPlayer, humanoidRootPart, originalCFrame)
                                end
                            end)
                        else
                            proceedWithKnock(Target, selectedPlayer, localPlayer, humanoidRootPart, originalCFrame)
                        end
                    end
                end
            end
        end
    end,
    DoubleClick = false,
})

local function proceedWithStomp(Target, selectedPlayer, localPlayer, humanoidRootPart, originalCFrame)
    local targetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
    local targetHead = Target.Character:FindFirstChild("Head")
    
    if targetHead and targetHRP then
        enableStickySilentAim(Target)
        
        local targetHeadPos = targetHead.Position
        local stickToHeadPos = Vector3.new(targetHeadPos.X, targetHeadPos.Y + 5, targetHeadPos.Z)
        humanoidRootPart.CFrame = CFrame.new(stickToHeadPos)
        
        task.spawn(function()
            while Target and Target.Character and not KnockCheck(Target) do
                if not game.Players:FindFirstChild(selectedPlayer) then
                    api:notify(selectedPlayer .. " left the game", 5)
                    updatePlayerDropdown()
                    disableStickySilentAim()
                    return
                end
                
                if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    break
                end
                
                local currentTool = localPlayer.Character:FindFirstChildOfClass("Tool")
                if not currentTool or not currentTool:FindFirstChild("Handle") then
                    break
                end
                
                local currentTargetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
                local currentTargetHead = Target.Character:FindFirstChild("Head")
                
                if currentTargetHRP and currentTargetHead then
                    local targetPos = currentTargetHRP.Position
                    
                    -- Randomized strafing around target
                    local strafeAngle = math.random() * math.pi * 2
                    local strafeRadius = math.random(6, 12)
                    local strafeHeight = math.random(3, 7)
                    
                    local strafeX = targetPos.X + math.cos(strafeAngle) * strafeRadius
                    local strafeZ = targetPos.Z + math.sin(strafeAngle) * strafeRadius
                    local strafePos = Vector3.new(strafeX, targetPos.Y + strafeHeight, strafeZ)
                    
                    -- Maintain upright orientation
                    humanoidRootPart.CFrame = CFrame.new(strafePos, targetPos)
                    humanoidRootPart.Position = strafePos
                    
                    if hasForcefield(Target) then
                        task.wait(0.1)
                    else
                        for i = 1, 3 do
                            if Target and Target.Character and not KnockCheck(Target) and not hasForcefield(Target) then
                                -- Keep strafing while shooting
                                local currentStrafeAngle = math.random() * math.pi * 2
                                local currentStrafeRadius = math.random(6, 12)
                                local currentStrafeHeight = math.random(3, 7)
                                
                                local currentStrafeX = targetPos.X + math.cos(currentStrafeAngle) * currentStrafeRadius
                                local currentStrafeZ = targetPos.Z + math.sin(currentStrafeAngle) * currentStrafeRadius
                                local currentStrafePos = Vector3.new(currentStrafeX, targetPos.Y + currentStrafeHeight, currentStrafeZ)
                                
                                humanoidRootPart.CFrame = CFrame.new(currentStrafePos, targetPos)
                                humanoidRootPart.Position = currentStrafePos
                                
                                stickyAimActive = true
                                MainEvent:FireServer("ShootGun", currentTool.Handle, currentTool.Handle.Position, currentTargetHead.Position, currentTargetHead, Vector3.new(0, 1, 0))
                                task.wait(0.01)
                                stickyAimActive = false
                                task.wait(0.05)
                            else
                                break
                            end
                        end
                    end
                else
                    break
                end
                
                task.wait(0.01)
            end
            
            if Target and Target.Character and KnockCheck(Target) then
                local originalHeadPos = Target.Character.Head.Position
                local stompAttempted = false
                
                task.wait(0.5)
                
                if Target.Character and Target.Character:FindFirstChild("LowerTorso") then
                    local bodyEffects = Target.Character:FindFirstChild("BodyEffects")
                    local originalHealth = 0
                    if bodyEffects and bodyEffects:FindFirstChild("Health") then
                        originalHealth = bodyEffects.Health.Value
                    end
                    
                    local currentLowerTorsoPos = Target.Character.LowerTorso.Position
                    local stickToLowerTorsoPos = Vector3.new(currentLowerTorsoPos.X, currentLowerTorsoPos.Y + 3, currentLowerTorsoPos.Z)
                    
                    humanoidRootPart.CFrame = CFrame.new(stickToLowerTorsoPos)
                    humanoidRootPart.Position = stickToLowerTorsoPos
                    
                    task.wait(0.1)
                    
                    if MainEvent then
                        -- Stomp first
                        MainEvent:FireServer("Stomp")
                        task.wait(0.5)
                        
                        -- Verify if target is really stomped
                        local bodyEffects = Target.Character:FindFirstChild("BodyEffects")
                        local currentHealth = 0
                        local isDead = false
                        
                        if bodyEffects then
                            local healthEffect = bodyEffects:FindFirstChild("Health")
                            if healthEffect then
                                currentHealth = healthEffect.Value
                            end
                            
                            local deathEffect = bodyEffects:FindFirstChild("SDeath")
                            if deathEffect then
                                isDead = deathEffect.Value
                            end
                        end
                        
                        local healthDiff = originalHealth - currentHealth
                        
                        if isDead then
                            api:notify('Target killed by stomp!', 3)
                        elseif healthDiff > 1.0 then
                            api:notify('Stomp hit!', 3)
                        else
                            -- If missed, stomp again
                            api:notify('Stomp might have missed, trying again...', 2)
                            task.wait(0.3)
                            MainEvent:FireServer("Stomp")
                            api:notify('Second stomp fired', 2)
                        end
                        
                        stompAttempted = true
                    else
                        api:notify('MainEvent not found for stomp!', 3)
                    end
                end
                
                if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    localPlayer.Character.HumanoidRootPart.CFrame = originalCFrame
                end
            else
                if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    localPlayer.Character.HumanoidRootPart.CFrame = originalCFrame
                end
            end
            
            disableStickySilentAim()
        end)
    end
end

local stompButton = playerListTab:AddButton({
    Text = 'Stomp',
    Func = function()
        local selectedPlayer = playerDropdown.Value
        if selectedPlayer and selectedPlayer ~= '' then
            local Target = game.Players:FindFirstChild(selectedPlayer)
            local localPlayer = game.Players.LocalPlayer
            
            if Target and Target.Character and localPlayer.Character then
                if KnockCheck(Target) then
                    local bodyEffects = Target.Character:FindFirstChild("BodyEffects")
                    local isDead = bodyEffects and bodyEffects:FindFirstChild("SDeath") and bodyEffects.SDeath.Value
                    
                    if isDead == false then
                        local savedPosition = localPlayer.Character.HumanoidRootPart.CFrame
                        
                        if Target.Character:FindFirstChild("LowerTorso") then
                            local bodyEffects = Target.Character:FindFirstChild("BodyEffects")
                            local originalHealth = 0
                            if bodyEffects and bodyEffects:FindFirstChild("Health") then
                                originalHealth = bodyEffects.Health.Value
                            end
                            
                            localPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(Target.Character.LowerTorso.Position + Vector3.new(0, 3, 0))
                            
                            task.wait(0.1)
                            
                            if MainEvent then
                                -- Stomp first
                                MainEvent:FireServer("Stomp")
                                
                                -- Go back to original position
                                localPlayer.Character.HumanoidRootPart.CFrame = savedPosition
                                task.wait(0.5)
                                
                                -- Verify if target is really stomped
                                local bodyEffects = Target.Character:FindFirstChild("BodyEffects")
                                local currentHealth = 0
                                local isDead = false
                                
                                if bodyEffects then
                                    local healthEffect = bodyEffects:FindFirstChild("Health")
                                    if healthEffect then
                                        currentHealth = healthEffect.Value
                                    end
                                    
                                    local deathEffect = bodyEffects:FindFirstChild("SDeath")
                                    if deathEffect then
                                        isDead = deathEffect.Value
                                    end
                                end
                                
                                local healthDiff = originalHealth - currentHealth
                                
                                if isDead then
                                    api:notify('Target killed by stomp!', 3)
                                elseif healthDiff > 1.0 then
                                    api:notify('Stomp hit!', 3)
                                else
                                    -- If missed, tp to target and stomp again
                                    api:notify('Stomp might have missed, trying again...', 2)
                                    
                                    localPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(Target.Character.LowerTorso.Position + Vector3.new(0, 3, 0))
                                    task.wait(0.3)
                                    
                                    MainEvent:FireServer("Stomp")
                                    api:notify('Second stomp fired', 2)
                                    
                                    task.wait(0.3)
                                    localPlayer.Character.HumanoidRootPart.CFrame = savedPosition
                                end
                            else
                                api:notify('MainEvent not found!', 3)
                                localPlayer.Character.HumanoidRootPart.CFrame = savedPosition
                            end
                        end
                    else
                        api:notify('Target is dead, cannot stomp', 3)
                    end
                else
                    local originalCFrame = localPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame
                    local humanoidRootPart = localPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local Tool = localPlayer.Character:FindFirstChildOfClass("Tool")
                    
                    if humanoidRootPart and Tool and Tool:FindFirstChild("Handle") then
                        local targetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
                        local targetHead = Target.Character:FindFirstChild("Head")
                        
                        if targetHead and targetHRP then
                            if hasForcefield(Target) then
                                api:notify(selectedPlayer .. " is in an active protective barrier. Waiting...", 10)
                                
                                task.spawn(function()
                                    while hasForcefield(Target) and Target and Target.Character do
                                        if not game.Players:FindFirstChild(selectedPlayer) then
                                            api:notify(selectedPlayer .. " left the game", 5)
                                            updatePlayerDropdown()
                                            return
                                        end
                                        task.wait(0.1)
                                    end
                                    
                                    if Target and Target.Character and proceedWithStomp then
                                        pcall(function()
                                            proceedWithStomp(Target, selectedPlayer, localPlayer, humanoidRootPart, originalCFrame)
                                        end)
                                    end
                                end)
                            else
                                if proceedWithStomp then
                                    pcall(function()
                                        proceedWithStomp(Target, selectedPlayer, localPlayer, humanoidRootPart, originalCFrame)
                                    end)
                                end
                            end
                        end
                    else
                        api:notify('Please equip your gun before using Stomp', 3)
                    end
                end
            else
                api:notify('Target player not found or not loaded', 3)
            end
        else
            api:notify('No player selected for stomp', 3)
        end
    end,
    DoubleClick = false,
})

local function proceedWithBring(Target, selectedPlayer, localPlayer, humanoidRootPart, originalCFrame)
    local targetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
    local targetHead = Target.Character:FindFirstChild("Head")
    
    if targetHead and targetHRP then
        enableStickySilentAim(Target)
        
        local targetHeadPos = targetHead.Position
        local stickToHeadPos = Vector3.new(targetHeadPos.X, targetHeadPos.Y + 5, targetHeadPos.Z)
        humanoidRootPart.CFrame = CFrame.new(stickToHeadPos)
        
        task.spawn(function()
            while Target and Target.Character and not KnockCheck(Target) do
                if not game.Players:FindFirstChild(selectedPlayer) then
                    api:notify(selectedPlayer .. " left the game", 5)
                    updatePlayerDropdown()
                    disableStickySilentAim()
                    return
                end
                
                if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    break
                end
                
                local currentTool = localPlayer.Character:FindFirstChildOfClass("Tool")
                if not currentTool or not currentTool:FindFirstChild("Handle") then
                    break
                end
                
                local currentTargetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
                local currentTargetHead = Target.Character:FindFirstChild("Head")
                
                if currentTargetHRP and currentTargetHead then
                    local targetPos = currentTargetHRP.Position
                    
                    -- Randomized strafing around target
                    local strafeAngle = math.random() * math.pi * 2
                    local strafeRadius = math.random(6, 12)
                    local strafeHeight = math.random(3, 7)
                    
                    local strafeX = targetPos.X + math.cos(strafeAngle) * strafeRadius
                    local strafeZ = targetPos.Z + math.sin(strafeAngle) * strafeRadius
                    local strafePos = Vector3.new(strafeX, targetPos.Y + strafeHeight, strafeZ)
                    
                    -- Maintain upright orientation
                    humanoidRootPart.CFrame = CFrame.new(strafePos, targetPos)
                    humanoidRootPart.Position = strafePos
                    
                    if hasForcefield(Target) then
                        task.wait(0.1)
                    else
                        for i = 1, 3 do
                            if Target and Target.Character and not KnockCheck(Target) and not hasForcefield(Target) then
                                -- Keep strafing while shooting
                                local currentStrafeAngle = math.random() * math.pi * 2
                                local currentStrafeRadius = math.random(6, 12)
                                local currentStrafeHeight = math.random(3, 7)
                                
                                local currentStrafeX = targetPos.X + math.cos(currentStrafeAngle) * currentStrafeRadius
                                local currentStrafeZ = targetPos.Z + math.sin(currentStrafeAngle) * currentStrafeRadius
                                local currentStrafePos = Vector3.new(currentStrafeX, targetPos.Y + currentStrafeHeight, currentStrafeZ)
                                
                                humanoidRootPart.CFrame = CFrame.new(currentStrafePos, targetPos)
                                humanoidRootPart.Position = currentStrafePos
                                
                                stickyAimActive = true
                                MainEvent:FireServer("ShootGun", currentTool.Handle, currentTool.Handle.Position, currentTargetHead.Position, currentTargetHead, Vector3.new(0, 1, 0))
                                task.wait(0.01)
                                stickyAimActive = false
                                task.wait(0.05)
                            else
                                if hasForcefield(Target) then
                                end
                                break
                            end
                        end
                    end
                else
                    break
                end
                
                task.wait(0.01)
            end
            
            if Target and Target.Character and KnockCheck(Target) then
                local originalHeadPos = Target.Character.Head.Position
                local pickupAttempted = false
                
                task.wait(0.5)
                
                if Target.Character and Target.Character:FindFirstChild("Head") then
                    local currentHeadPos = Target.Character.Head.Position
                    local stickToHeadPos = Vector3.new(currentHeadPos.X, currentHeadPos.Y + 5, currentHeadPos.Z)
                    
                    humanoidRootPart.CFrame = CFrame.new(stickToHeadPos)
                    humanoidRootPart.Position = stickToHeadPos
                    
                    local VirtualInputManager = game:GetService("VirtualInputManager")
                    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.G, false, game)
                    task.wait(0.05)
                    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.G, false, game)
                    
                    pickupAttempted = true
                    
                    task.wait(0.5)
                end
                
                if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    localPlayer.Character.HumanoidRootPart.CFrame = originalCFrame
                end
            else
                if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    localPlayer.Character.HumanoidRootPart.CFrame = originalCFrame
                end
            end
            
            disableStickySilentAim()
        end)
    end
end


local stompSubButton = stompButton:AddButton({
    Text = 'Bring',
    Func = function()
        local selectedPlayer = playerDropdown.Value
        if selectedPlayer and selectedPlayer ~= '' then
            local Target = game.Players:FindFirstChild(selectedPlayer)
            local localPlayer = game.Players.LocalPlayer
            
            if Target and Target.Character and localPlayer.Character then
                local originalCFrame = localPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame
                local humanoidRootPart = localPlayer.Character:FindFirstChild("HumanoidRootPart")
                local Tool = localPlayer.Character:FindFirstChildOfClass("Tool")
                
                if humanoidRootPart and Tool and Tool:FindFirstChild("Handle") then
                    local targetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
                    local targetHead = Target.Character:FindFirstChild("Head")
                    
                    if targetHead and targetHRP then
                        if hasForcefield(Target) then
                            api:notify(selectedPlayer .. " is in an active protective barrier. Waiting...", 10)
                            
                            task.spawn(function()
                                while hasForcefield(Target) and Target and Target.Character do
                                    if not game.Players:FindFirstChild(selectedPlayer) then
                                        api:notify(selectedPlayer .. " left the game", 5)
                                        updatePlayerDropdown()
                                        return
                                    end
                                    task.wait(0.1)
                                end
                                
                                if Target and Target.Character then
                                    proceedWithBring(Target, selectedPlayer, localPlayer, humanoidRootPart, originalCFrame)
                                end
                            end)
                        else
                            proceedWithBring(Target, selectedPlayer, localPlayer, humanoidRootPart, originalCFrame)
                        end
                    end
                end
            end
        end
    end,
    DoubleClick = false,
})


playerListTab:AddLabel('@wanderkidd', true)


local function safe_notify(msg, lifetime)
    if not msg then return end
    lifetime = lifetime or 3
    
    pcall(function()
        if api and type(api.notify) == "function" then
            api:notify(msg, lifetime)
        else
            print("[Notification]: " .. tostring(msg))
        end
    end)
end

local function set_desync_cframe(cframe)
    if api and type(api.set_desync_cframe) == "function" then
        pcall(function()
            api:set_desync_cframe(cframe)
        end)
    end
end

local function safe_call(fn, ...)
    if type(fn) ~= "function" then return nil end
    local ok, res = pcall(fn, ...)
    if not ok then
        return nil
    end
    return res
end

local function call_api(name, ...)
    if type(api) ~= "table" then return nil end
    local candidates = { name, name:gsub("_([a-z])", function(c) return c:upper() end), name:gsub("_", ""), name:lower(), name:upper() }
    for _, cand in ipairs(candidates) do
        local fn = api[cand]
        if type(fn) == "function" then
            return safe_call(fn, api, ...)
        end
    end
    return nil
end

local function has_api(name)
    if type(api) ~= "table" then return false end
    local candidates = { name, name:gsub("_([a-z])", function(c) return c:upper() end), name:gsub("_", ""), name:lower(), name:upper() }
    for _, cand in ipairs(candidates) do
        if type(api[cand]) == "function" then return true end
    end
    return false
end

local function safe_wait(sec)
    if type(task) == "table" and type(task.wait) == "function" then
        return task.wait(sec)
    elseif type(wait) == "function" then
        return wait(sec)
    else
        local t0 = os.clock()
        while os.clock() - t0 < (sec or 0) do end
        return nil
    end
end

local function safe_spawn(fn)
    if type(task) == "table" and type(task.spawn) == "function" then
        return task.spawn(fn)
    elseif type(spawn) == "function" then
        return spawn(fn)
    else
        local co = coroutine.create(fn)
        coroutine.resume(co)
        return co
    end
end

local left = strafesTab
local addons_left = addonsTab

local function make_control(default)
    local ctrl = { Value = default }
    function ctrl:SetValue(v) ctrl.Value = v end
    function ctrl:OnChanged(_) end
    ctrl.Properties = {}
    function ctrl:Display() end
    function ctrl:DoClick() end
    return ctrl
end

if not left then
    left = {
        AddToggle = function(_, id, opts) return make_control(opts and opts.Default or false) end,
        AddSlider = function(_, id, opts) return make_control(opts and opts.Default or 0) end,
        AddDropdown = function(_, id, opts) return make_control(opts and opts.Default or 1) end,
    }
end

if not addons_left then
    addons_left = {
        AddToggle = function(_, id, opts) return make_control(opts and opts.Default or false) end,
        AddSlider = function(_, id, opts) return make_control(opts and opts.Default or 0) end,
        AddInput = function(_, id, opts) return make_control(opts and opts.Default or "") end,
        AddColorPicker = function(_, id, opts) return make_control(opts and opts.Default or Color3.fromRGB(255, 255, 255)) end,
        AddButton = function(_, id, opts) 
            local ctrl = make_control(false)
            if opts and opts.Func then
                ctrl.Func = opts.Func
            else
                ctrl.Func = function() end
            end
            return ctrl
        end,
        AddKeybind = function(_, id, opts) return make_control(opts and opts.Default or "V") end,
    }
end

-- Strafes Controls
local enable = left:AddToggle("strafes_enable", { Text = "Enable", Default = true, Tooltip = "Enable/disable strafe system" })
local force_unsafe = left:AddToggle("strafes_force_unsafe", { Text = "Force Unsafe", Default = false, Tooltip = "Force unsafe strafe settings" })
local ignore_visibility = left:AddToggle("strafes_ignore_visibility", { Text = "Ignore Visibility Check", Default = false, Tooltip = "Ignore target visibility when strafing" })
local void_resolver = left:AddToggle("strafes_void_resolver", { Text = "VoidResolver", Default = true, Tooltip = "Prevent targeting players in void (distance > 5000 studs)" })
local anti_predictive = left:AddToggle("strafes_anti_predictive", { Text = "Anti-Predictive Path", Default = true, Tooltip = "Use anti-predictive movement patterns" })

left:AddDivider()

local mode_dropdown = left:AddDropdown("strafes_mode", { Text = "Strafe Mode", Default = 1, Values = {"Chaos","Burst","Void","Adaptive","Jitter","Micro","Retreat","Push","Counter","Stutter","Orbital","Escape","Quantum","AntiAim","Pringle","Random Spike","Circle","Figure8","Gridshot","Spiral","SideDash","ZigZag","PulseInOut","Anchors","YoYo","Pendulum","Void Strafe","Adaptive Strafe"}, Tooltip = "Select strafe movement pattern" })

local slider_base_height = left:AddSlider("strafes_base_height", { Text = "Base Height", Min = -15, Max = 70, Default = 54, Rounding = 1, Suffix = " studs", Compact = true, Tooltip = "How high/low you strafe" })
local slider_base_distance = left:AddSlider("strafes_base_distance", { Text = "Base Distance", Min = 0, Max = 70, Default = 34, Rounding = 1, Suffix = " studs", Compact = true, Tooltip = "How far from target" })
local slider_base_speed = left:AddSlider("strafes_base_speed", { Text = "Speed Multiplier", Min = 0.5, Max = 10.0, Default = 1.0, Rounding = 1, Suffix = "x", Compact = true, Tooltip = "How fast strafes move" })
local slider_randomness = left:AddSlider("strafes_randomness", { Text = "Randomness Intensity", Min = 0, Max = 2, Default = 2, Rounding = 0, Suffix = "x", Compact = true, Tooltip = "How unpredictable movement is" })

left:AddDivider()

local toggle_cycle = left:AddToggle("strafes_cycle", { Text = "Auto Cycle Modes", Default = false, Tooltip = "Automatically cycle between strafe modes" })
local slider_cycle_interval = left:AddSlider("strafes_cycle_interval", { Text = "Cycle Interval", Min = 0.5, Max = 3.0, Default = 1.0, Rounding = 1, Suffix = "s", Compact = true, Tooltip = "How fast to switch modes" })
local picker_cycle_modes = left:AddDropdown("strafes_cycle_modes", { Text = "Cycle Modes", Default = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}, Values = {"Chaos","Burst","Void","Adaptive","Jitter","Micro","Retreat","Push","Counter","Stutter","Orbital","Escape","Quantum","AntiAim","Pringle"}, Multi = true, Tooltip = "Select which modes to cycle through" })

if left and type(left.AddLabel) == "function" then
    left:AddLabel("@wanderkidd")
end

local better_void_toggle = addons_left:AddToggle("better_void_enabled", { Text = "Better Void", Default = false })
local keybind_void = nil
if better_void_toggle and type(better_void_toggle.AddKeyPicker) == "function" then
    keybind_void = better_void_toggle:AddKeyPicker("better_void_keybind", { Default = "N", Mode = "Toggle", Text = "Void [Dimensional tear Jutsu]", NoUI = false, SyncToggleState = true })
end
local slider_void_range = addons_left:AddSlider("better_void_range", { Text = "Range", Min = 1000, Max = 10000000, Default = 250000, Rounding = 0, Suffix = "", Compact = true })

-- Create dependency box for BetterVoid options
local better_void_depbox = addons_left:AddDependencyBox()

-- Add Randomize Y-Axis as first dependency
local toggle_randomize_y = better_void_depbox:AddToggle("better_void_randomize_y", { Text = "Randomize Y-Axis", Default = true })

-- Add Spam as second dependency
local toggle_spam = better_void_depbox:AddToggle("better_void_spam", { Text = "Spam", Default = false })

-- Create sub-dependency box for spam settings
local spam_depbox = better_void_depbox:AddDependencyBox()
local slider_void_duration = spam_depbox:AddSlider("better_void_duration", { Text = "Void Duration", Min = 0.02, Max = 1, Default = 0.5, Rounding = 2, Suffix = "", Compact = true })
local slider_stop_duration = spam_depbox:AddSlider("better_void_stop_duration", { Text = "Stop Duration)", Min = 0.02, Max = 1, Default = 0.15, Rounding = 2, Suffix = "", Compact = true })

-- Setup dependencies
better_void_depbox:SetupDependencies({
    { better_void_toggle, true }
})

spam_depbox:SetupDependencies({
    { toggle_spam, true }
})

addons_left:AddDivider()

local toggle_custom_hit_sound = addons_left:AddToggle("custom_hit_sound", { Text = "Custom Hit Sound", Default = false })
local input_sound_id = addons_left:AddInput("sound_id", { Text = "Sound ID", Default = "92812654212522", Numeric = true, Finished = true })
local slider_volume = addons_left:AddSlider("sound_volume", { Text = "Volume", Min = 0, Max = 100, Default = 50, Rounding = 0, Suffix = "%", Compact = true })
local slider_sound_speed = addons_left:AddSlider("sound_speed", { Text = "Sound Speed", Min = 0.1, Max = 2.0, Default = 1.0, Rounding = 1, Suffix = "x", Compact = true })

local better_void_connections = {}
local addon_loaded = true

local better_void_loop = task.spawn(function()
    local spam_start_time = 0
    local last_spam_state = false
    
    while addon_loaded do
            local range = slider_void_range and slider_void_range.Value or 250000000
            local randomize_y = toggle_randomize_y and toggle_randomize_y.Value or true
        local spam_mode = toggle_spam and toggle_spam.Value or false
        local void_enabled = better_void_toggle and better_void_toggle.Value
        
        -- Reset spam timer when spam is turned on
        if spam_mode and not last_spam_state then
            spam_start_time = tick()
        end
        last_spam_state = spam_mode
        
        if void_enabled then
            if spam_mode then
                -- Spam mode with customizable void and stop durations
                local void_duration = slider_void_duration and slider_void_duration.Value or 0.7
                local stop_duration = slider_stop_duration and slider_stop_duration.Value or 0.2
                local spam_cycle_duration = void_duration + stop_duration
                
                local current_time = tick()
                local cycle_time = (current_time - spam_start_time) % spam_cycle_duration
                
                if cycle_time < void_duration then
                    -- Void for custom duration
            local x = math.random(-range, range)
            local z = math.random(-range, range)
            local y = randomize_y and math.random(-range, range) or 0
            
            set_desync_cframe(CFrame.new(x, y, z))
                    task.wait() -- Normal frame rate during void phase
                else
                    -- Stop voiding for custom duration
                    task.wait(0.1) -- Wait during stop phase
                end
            else
                -- Normal void mode
                local x = math.random(-range, range)
                local z = math.random(-range, range)
                local y = randomize_y and math.random(-range, range) or 0
                
                set_desync_cframe(CFrame.new(x, y, z))
        task.wait()
            end
        else
            task.wait()
        end
    end
end)

table.insert(better_void_connections, better_void_loop)

if addons_left and type(addons_left.AddLabel) == "function" then
    addons_left:AddLabel("@wanderkidd")
end

if addons_left and type(addons_left.AddButton) == "function" then
    local success, result = pcall(function()
        return addons_left:AddButton("Animation Pack", { Text = "Animation Pack", Func = function()
        repeat
            wait()
        until game:IsLoaded()
        and game.Players.LocalPlayer.Character:FindFirstChild("FULLY_LOADED_CHAR")
        and game.Players.LocalPlayer.PlayerGui.MainScreenGui:FindFirstChild("AnimationPack")
        and game.Players.LocalPlayer.PlayerGui.MainScreenGui:FindFirstChild("AnimationPlusPack")
        
        local Animations = game.ReplicatedStorage:WaitForChild("ClientAnimations")

        local anims = {
            "Lean", "Lay", "Dance1", "Dance2", "Greet", "Chest Pump", "Praying",
            "TheDefault", "Sturdy", "Rossy", "Griddy", "TPose", "SpeedBlitz"
        }
        for _, name in ipairs(anims) do
            local a = Animations:FindFirstChild(name)
            if a then a:Destroy() end
        end

        local function NewAnim(name, id)
            local a = Instance.new("Animation", Animations)
            a.Name = name
            a.AnimationId = "rbxassetid://" .. id
            return a
        end

        local LeanAnimation = NewAnim("Lean", "3152375249")
        local LayAnimation = NewAnim("Lay", "3152378852")
        local Dance1Animation = NewAnim("Dance1", "3189773368")
        local Dance2Animation = NewAnim("Dance2", "3189776546")
        local GreetAnimation = NewAnim("Greet", "3189777795")
        local ChestPumpAnimation = NewAnim("Chest Pump", "3189779152")
        local PrayingAnimation = NewAnim("Praying", "3487719500")
        local TheDefaultAnimation = NewAnim("TheDefault", "11710529975")
        local SturdyAnimation = NewAnim("Sturdy", "11710524717")
        local RossyAnimation = NewAnim("Rossy", "11710527244")
        local GriddyAnimation = NewAnim("Griddy", "11710529220")
        local TPoseAnimation = NewAnim("TPose", "11710524200")
        local SpeedBlitzAnimation = NewAnim("SpeedBlitz", "11710541744")

        function AnimationPack(Character)
            Character:WaitForChild("Humanoid")
            repeat wait() until Character:FindFirstChild("FULLY_LOADED_CHAR")
                and game.Players.LocalPlayer.PlayerGui.MainScreenGui:FindFirstChild("AnimationPack")
                and game.Players.LocalPlayer.PlayerGui.MainScreenGui:FindFirstChild("AnimationPlusPack")

            local Player = game.Players.LocalPlayer
            local Humanoid = Character.Humanoid
            local AnimationPack = Player.PlayerGui.MainScreenGui.AnimationPack
            local AnimationPackPlus = Player.PlayerGui.MainScreenGui.AnimationPlusPack
            local ScrollingFrame = AnimationPack.ScrollingFrame
            local CloseButton = AnimationPack.CloseButton
            local ScrollingFramePlus = AnimationPackPlus.ScrollingFrame
            local CloseButtonPlus = AnimationPackPlus.CloseButton

            local Animator = Humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", Humanoid)

            local animations = {
                Lean = Humanoid:LoadAnimation(LeanAnimation),
                Lay = Humanoid:LoadAnimation(LayAnimation),
                Dance1 = Humanoid:LoadAnimation(Dance1Animation),
                Dance2 = Humanoid:LoadAnimation(Dance2Animation),
                Greet = Humanoid:LoadAnimation(GreetAnimation),
                ChestPump = Humanoid:LoadAnimation(ChestPumpAnimation),
                Praying = Humanoid:LoadAnimation(PrayingAnimation),
                TheDefault = Humanoid:LoadAnimation(TheDefaultAnimation),
                Sturdy = Humanoid:LoadAnimation(SturdyAnimation),
                Rossy = Humanoid:LoadAnimation(RossyAnimation),
                Griddy = Humanoid:LoadAnimation(GriddyAnimation),
                TPose = Humanoid:LoadAnimation(TPoseAnimation),
                SpeedBlitz = Humanoid:LoadAnimation(SpeedBlitzAnimation)
            }

            AnimationPack.Visible = true
            AnimationPackPlus.Visible = true
            ScrollingFrame.UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
            ScrollingFramePlus.UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder

            local function RenameButtons(frame, RenameMap)
                for _, btn in pairs(frame:GetChildren()) do
                    if btn:IsA("TextButton") and RenameMap[btn.Text] then
                        btn.Name = RenameMap[btn.Text]
                    end
                end
            end

            RenameButtons(ScrollingFrame, {
                ["Lean"] = "LeanButton",
                ["Lay"] = "LayButton",
                ["Dance1"] = "Dance1Button",
                ["Dance2"] = "Dance2Button",
                ["Greet"] = "GreetButton",
                ["Chest Pump"] = "ChestPumpButton",
                ["Praying"] = "PrayingButton",
            })

            RenameButtons(ScrollingFramePlus, {
                ["The Default"] = "TheDefaultButton",
                ["Sturdy"] = "SturdyButton",
                ["Rossy"] = "RossyButton",
                ["Griddy"] = "GriddyButton",
                ["T Pose"] = "TPoseButton",
                ["Speed Blitz"] = "SpeedBlitzButton",
            })

            local function StopAll()
                for _, anim in pairs(animations) do anim:Stop() end
            end

            local function ConnectButton(ButtonName, AnimKey, parent)
                local btn = parent:FindFirstChild(ButtonName)
                if btn then
                    btn.MouseButton1Click:Connect(function()
                        StopAll()
                        animations[AnimKey]:Play()
                    end)
                end
            end

            ConnectButton("LeanButton", "Lean", ScrollingFrame)
            ConnectButton("LayButton", "Lay", ScrollingFrame)
            ConnectButton("Dance1Button", "Dance1", ScrollingFrame)
            ConnectButton("Dance2Button", "Dance2", ScrollingFrame)
            ConnectButton("GreetButton", "Greet", ScrollingFrame)
            ConnectButton("ChestPumpButton", "ChestPump", ScrollingFrame)
            ConnectButton("PrayingButton", "Praying", ScrollingFrame)

            ConnectButton("TheDefaultButton", "TheDefault", ScrollingFramePlus)
            ConnectButton("SturdyButton", "Sturdy", ScrollingFramePlus)
            ConnectButton("RossyButton", "Rossy", ScrollingFramePlus)
            ConnectButton("GriddyButton", "Griddy", ScrollingFramePlus)
            ConnectButton("TPoseButton", "TPose", ScrollingFramePlus)
            ConnectButton("SpeedBlitzButton", "SpeedBlitz", ScrollingFramePlus)

            AnimationPack.MouseButton1Click:Connect(function()
                ScrollingFrame.Visible = true
                CloseButton.Visible = true
                AnimationPackPlus.Visible = false
            end)

            AnimationPackPlus.MouseButton1Click:Connect(function()
                ScrollingFramePlus.Visible = true
                CloseButtonPlus.Visible = true
                AnimationPack.Visible = false
            end)

            CloseButton.MouseButton1Click:Connect(function()
                ScrollingFrame.Visible = false
                CloseButton.Visible = false
                AnimationPackPlus.Visible = true
            end)

            CloseButtonPlus.MouseButton1Click:Connect(function()
                ScrollingFramePlus.Visible = false
                CloseButtonPlus.Visible = false
                AnimationPack.Visible = true
            end)

            Humanoid.Running:Connect(StopAll)
            game.Players.LocalPlayer.CharacterAdded:Connect(StopAll)
        end

        AnimationPack(game.Players.LocalPlayer.Character)
        game.Players.LocalPlayer.CharacterAdded:Connect(AnimationPack)
        end, Tooltip = "Load animation pack" })
        end)
    if not success then
    end
end

local function connect_control(ctrl, fn)
    if type(ctrl) ~= "table" or type(fn) ~= "function" then return end
    
    pcall(function()
        if type(ctrl.OnChanged) == "function" then
            pcall(function() ctrl:OnChanged(fn) end)
            return
        end
        
        if type(ctrl.OnChanged) == "table" and type(ctrl.OnChanged.Connect) == "function" then
            pcall(function() ctrl.OnChanged:Connect(fn) end)
            return
        end
        
        if type(ctrl.Changed) == "table" and type(ctrl.Changed.Connect) == "function" then
            pcall(function() ctrl.Changed:Connect(function(prop)
                if prop == "Value" or prop == "value" then
                    pcall(function() fn(val(ctrl, nil)) end)
                end
            end) end)
            return
        end
    end)
    
    local hooked = false
    pcall(function()
        local ok, v = pcall(function() return ctrl.Value end)
        if ok and v ~= nil and type(v) == "userdata" and type(v.GetPropertyChangedSignal) == "function" then
            pcall(function()
                v:GetPropertyChangedSignal("Value"):Connect(function()
                    pcall(function() fn(val(ctrl, nil)) end)
                end)
            end)
            hooked = true
        end
    end)
    
    if not hooked then
        safe_spawn(function()
            local last = nil
            while true do
                local ok2, v = pcall(function() return val(ctrl, nil) end)
                if not ok2 then
                    break
                end
                if v ~= last then
                    last = v
                    pcall(fn, v)
                end
                safe_wait(0.1)
            end
        end)
    end
end

local function val(ctrl, d)
    if not ctrl then return d end
    local ok, v = pcall(function() return ctrl.Value end)
    if ok then
        if (type(v) == "table" or type(v) == "userdata") then
            local ok2, inner = pcall(function() return v.Value end)
            if ok2 and inner ~= nil then return inner end
        end
        if v ~= nil then return v end
    end
    
    if type(ctrl.GetValue) == "function" then
        local ok3, v3 = pcall(function() return ctrl:GetValue() end)
        if ok3 and v3 ~= nil then return v3 end
    end
    
    if type(ctrl.Get) == "function" then
        local ok4, v4 = pcall(function() return ctrl:Get() end)
        if ok4 and v4 ~= nil then return v4 end
    end
    
    return d
end

connect_control(enable, function(v) pcall(register) end)
connect_control(force_unsafe, function(v) pcall(register) end)
connect_control(ignore_visibility, function(v) pcall(register) end)
connect_control(void_resolver, function(v) pcall(register) end)
connect_control(anti_predictive, function(v) pcall(register) end)
connect_control(mode_dropdown, function(v) pcall(register) end)
connect_control(toggle_cycle, function(v) pcall(register) end)
connect_control(slider_cycle_interval, function(v) pcall(register) end)
connect_control(picker_cycle_modes, function(v) pcall(register) end)

local function register()
    local function compute()
        if not val(enable, false) then return nil end
        
        local client_cf = call_api("get_client_cframe")
        if not client_cf then return nil end
        
        local center = client_cf.p
        local target_cache = call_api("get_target_cache", "ragebot")
        local ignore_visibility_check = val(ignore_visibility, false)
        
        if target_cache and target_cache.part and target_cache.part.Position then 
            -- Void Resolver Check (hardened)
            if val(void_resolver, false) then
                local pos = target_cache.part.Position
                local dist_from_client = (pos - client_cf.p).Magnitude
                local void_limit = val(slider_void_range, 250000)
                local y = pos.Y
                -- conditions indicating target is in or beyond void
                if not pos or dist_from_client > 5000 or y < -1000 or y > 100000 or pos.Magnitude > (void_limit * 2) then
                    return nil
                end
            end
            center = target_cache.part.Position
        elseif not ignore_visibility_check then
            return nil
        else
            local camera = workspace.CurrentCamera
            if camera then
                local camera_cf = camera.CFrame
                center = camera_cf.p + camera_cf.LookVector * 10
            else
                center = client_cf.p
            end
        end
        
        local distance = val(slider_base_distance, 34)
        local height = val(slider_base_height, 54)
        local speed_multiplier = val(slider_base_speed, 1.0)
        local randomness = val(slider_randomness, 2)
        
        local cycle_enabled = val(toggle_cycle, false)
        local cycle_interval = val(slider_cycle_interval, 1.0)
        
        local mode = "Chaos"
        
        if cycle_enabled and picker_cycle_modes then
            local t = (type(tick) == "function") and tick() or os.clock()
            local selected_modes = {}
            local picker_values = val(picker_cycle_modes, {})
            local all_modes = {"Chaos","Burst","Void","Adaptive","Jitter","Micro","Retreat","Push","Counter","Stutter","Orbital","Escape","Quantum","AntiAim","Pringle"}

            -- Normalize picker_values to a list of mode NAMES
            if type(picker_values) == "table" then
                local detected_boolean_map = false
                for k, v in pairs(picker_values) do
                    if type(v) == "boolean" then
                        detected_boolean_map = true
                        break
                    end
                end

                if detected_boolean_map then
                    -- Forms supported:
                    -- { ["Chaos"]=true, ["Burst"]=false }
                    -- { [1]=true, [3]=true }
                    for k, is_selected in pairs(picker_values) do
                        if is_selected then
                            if type(k) == "string" then
                                table.insert(selected_modes, k)
                            elseif type(k) == "number" then
                                local name = all_modes[k]
                                if name then table.insert(selected_modes, name) end
                            end
                        end
                    end
                else
                    -- Likely an array of indices or names: {1,2,5} or {"Chaos","Burst"}
                    for _, entry in ipairs(picker_values) do
                        if type(entry) == "number" then
                            local name = all_modes[entry]
                            if name then table.insert(selected_modes, name) end
                        elseif type(entry) == "string" then
                            table.insert(selected_modes, entry)
                        end
                    end
                end
            end

            if #selected_modes == 0 then
                selected_modes = all_modes
            end

            if #selected_modes > 0 then
                local cycle_index = math.floor(t / cycle_interval) % #selected_modes + 1
                mode = selected_modes[cycle_index]
            end
        else
            local mode_dropdown_val = val(mode_dropdown, 1)
            local mode_names = {"Chaos","Burst","Void","Adaptive","Jitter","Micro","Retreat","Push","Counter","Stutter","Orbital","Escape","Quantum","AntiAim","Pringle","Random Spike","Circle","Figure8","Gridshot","Spiral","SideDash","ZigZag","PulseInOut","Anchors","YoYo","Pendulum","Void Strafe","Adaptive Strafe"}
            mode = mode_names[mode_dropdown_val] or "Chaos"
        end
        
        local current_mode = mode
        getgenv().wanderkidd_current_strafe_mode = current_mode
        
        local t = (type(tick) == "function") and tick() or os.clock()

        -- Per-mode overrides to make modes feel distinctly different even with same base sliders
        do
            local baseDist, baseH, baseS, baseR = distance, height, speed_multiplier, randomness
            local function set(dMul, hOffset, sMul, rMul)
                distance = baseDist * (dMul or 1)
                height = baseH + (hOffset or 0)
                speed_multiplier = baseS * (sMul or 1)
                randomness = baseR * (rMul or 1)
            end
            if current_mode == "Chaos" then
                set(1.00, 0, 1.20, 1.50)
            elseif current_mode == "Burst" then
                set(0.70, 2 + 3*math.sin(t*2), 1.40, 0.80)
            elseif current_mode == "Void" then
                set(0.85, -3, 0.80, 0.50)
            elseif current_mode == "Adaptive" then
                set(0.90, 4*math.sin(t*0.7), 1.10, 1.00)
            elseif current_mode == "Jitter" then
                set(0.50, 1*math.sin(t*9), 1.80, 2.00)
            elseif current_mode == "Micro" then
                set(0.30, 0, 2.50, 0.40)
            elseif current_mode == "Retreat" then
                set(1.30, 6*math.sin(t*0.5), 0.90, 0.60)
            elseif current_mode == "Push" then
                set(0.90, -2, 1.60, 0.70)
            elseif current_mode == "Counter" then
                set(0.75, 0, 1.30, 0.60)
            elseif current_mode == "Stutter" then
                set(0.60, 3*math.sin(t*1.1), 2.20, 0.50)
            elseif current_mode == "Orbital" then
                set(1.10, 4*math.sin(t*0.8), 0.90, 0.80)
            elseif current_mode == "Escape" then
                set(0.95, -4*math.abs(math.sin(t)), 1.50, 0.50)
            elseif current_mode == "Quantum" then
                set(0.50, 2*math.sin(t*3.1), 1.70, 1.20)
            elseif current_mode == "AntiAim" then
                set(0.40, (math.random()-0.5)*6, 2.20, 1.80)
            elseif current_mode == "Pringle" then
                set(0.80, 2*math.sin(t*3.14159), 1.10, 0.70)
            elseif current_mode == "Random Spike" then
                set(0.70, (math.random()-0.5)*8, 2.00, 1.60)
            elseif current_mode == "Circle" then
                set(1.00, 0, 1.00, 0.30)
            elseif current_mode == "Figure8" then
                set(0.85, 2*math.sin(t*1.2), 1.10, 0.60)
            elseif current_mode == "Gridshot" then
                set(0.55, 0, 2.60, 0.20)
            elseif current_mode == "Spiral" then
                set(1.20, 3*math.sin(t*0.6), 0.80, 0.50)
            elseif current_mode == "SideDash" then
                set(0.60, 0, 2.20, 0.40)
            elseif current_mode == "ZigZag" then
                set(0.75, 1.5*math.sin(t*2.7), 1.80, 0.70)
            elseif current_mode == "PulseInOut" then
                set(0.90, 2*math.sin(t*1.8), 1.20, 0.60)
            elseif current_mode == "Anchors" then
                set(0.65, 0, 0.90, 0.40)
            elseif current_mode == "YoYo" then
                set(0.50, 5*math.abs(math.sin(t*2)) - 2, 2.40, 0.50)
            elseif current_mode == "Pendulum" then
                set(1.10, 2*math.sin(t), 0.80, 0.40)
            elseif current_mode == "Void Strafe" then
                set(0.80, -2, 1.20, 0.40)
            elseif current_mode == "Adaptive Strafe" then
                set(0.85, 2*math.sin(t*1.4), 1.30, 0.80)
            else
                set(1.00, 0, 1.00, 1.00)
            end
        end
        local x, z = 0, 0
        
        if current_mode == "Chaos" then
            local chaos_t = t * 15 * speed_multiplier
            x = distance * 0.8 * (math.sin(chaos_t * 1.3) * math.cos(chaos_t * 2.7) + math.sin(chaos_t * 4.1) * 0.3)
            z = distance * 0.8 * (math.cos(chaos_t * 1.7) * math.sin(chaos_t * 3.2) + math.cos(chaos_t * 5.9) * 0.4)
        elseif current_mode == "Burst" then
            local burst_t = t * 12 * speed_multiplier
            local burst_phase = math.floor(burst_t / (math.pi * 0.5)) % 8
            local burst_scale = distance * 0.6
            if burst_phase == 0 or burst_phase == 4 then
                x = burst_scale * math.sin(burst_t * 3)
                z = 0
            elseif burst_phase == 1 or burst_phase == 5 then
                x = 0
                z = burst_scale * math.cos(burst_t * 3)
            elseif burst_phase == 2 or burst_phase == 6 then
                x = -burst_scale * math.sin(burst_t * 3)
                z = 0
            else
                x = 0
                z = -burst_scale * math.cos(burst_t * 3)
            end
        elseif current_mode == "Void" then
            local void_t = t * 5 * speed_multiplier
            local void_scale = distance * 0.7
            x = void_scale * math.floor(math.sin(void_t * 2) * 3) / 3
            z = void_scale * math.floor(math.cos(void_t * 2) * 3) / 3
        elseif current_mode == "Adaptive" then
            local adaptive_t = t * 8 * speed_multiplier
            local adaptive_scale = distance * 0.5
            x = adaptive_scale * (math.sin(adaptive_t) + math.sin(adaptive_t * 2.1) * 0.5)
            z = adaptive_scale * (math.cos(adaptive_t * 1.3) + math.cos(adaptive_t * 3.7) * 0.3)
        elseif current_mode == "Jitter" then
            local jitter_t = t * 25 * speed_multiplier
            local jitter_scale = distance * 0.3
            x = jitter_scale * (math.sin(jitter_t) + (math.random() - 0.5) * 2)
            z = jitter_scale * (math.cos(jitter_t) + (math.random() - 0.5) * 2)
        elseif current_mode == "Micro" then
            local micro_t = t * 40 * speed_multiplier
            local micro_scale = distance * 0.15
            x = micro_scale * math.tan(micro_t * 0.1) * 0.3
            z = micro_scale * math.atan(micro_t * 0.1) * 0.3
        elseif current_mode == "Retreat" then
            local retreat_t = t * 3 * speed_multiplier
            local retreat_scale = distance * 1.2
            x = retreat_scale * math.log(math.abs(math.sin(retreat_t)) + 0.1) * math.sign(math.sin(retreat_t))
            z = retreat_scale * math.log(math.abs(math.cos(retreat_t)) + 0.1) * math.sign(math.cos(retreat_t))
        elseif current_mode == "Push" then
            local push_t = t * 6 * speed_multiplier
            local push_scale = distance * 0.2
            local push_force = 3 + 2 * math.sin(push_t * 1.2)
            x = push_scale * math.pow(math.sin(push_t * 2), 3) * push_force
            z = push_scale * math.pow(math.cos(push_t * 2), 3) * push_force
        elseif current_mode == "Counter" then
            local counter_t = t * 10 * speed_multiplier
            local counter_scale = distance * 0.6
            x = counter_scale * math.sqrt(math.abs(math.sin(counter_t))) * math.sign(math.sin(counter_t))
            z = counter_scale * math.sqrt(math.abs(math.cos(counter_t))) * math.sign(math.cos(counter_t))
        elseif current_mode == "Stutter" then
            local stutter_t = t * 35 * speed_multiplier
            local stutter_scale = distance * 0.4
            local stutter_step = math.floor(stutter_t / (math.pi * 0.1))
            x = stutter_scale * (stutter_step % 3 == 0 and 1 or 0) * math.sin(stutter_step * 0.5)
            z = stutter_scale * (stutter_step % 3 == 1 and 1 or 0) * math.cos(stutter_step * 0.5)
        elseif current_mode == "Orbital" then
            local orbital_t = t * 4 * speed_multiplier
            local orbital_scale = distance * 0.9
            x = orbital_scale * math.sin(orbital_t) * (1 + 0.3 * math.sin(orbital_t * 5))
            z = orbital_scale * math.cos(orbital_t) * (1 + 0.3 * math.cos(orbital_t * 5))
        elseif current_mode == "Escape" then
            local escape_t = t * 9 * speed_multiplier
            local escape_scale = distance * 0.8
            x = escape_scale * math.exp(-math.abs(math.sin(escape_t))) * math.sign(math.sin(escape_t))
            z = escape_scale * math.exp(-math.abs(math.cos(escape_t))) * math.sign(math.cos(escape_t))
        elseif current_mode == "Quantum" then
            local quantum_t = t * 14 * speed_multiplier
            local quantum_scale = distance * 0.3
            x = quantum_scale * math.sin(quantum_t * 2) * math.sin(quantum_t * 3) * math.sin(quantum_t * 5)
            z = quantum_scale * math.cos(quantum_t * 2) * math.cos(quantum_t * 3) * math.cos(quantum_t * 5)
        elseif current_mode == "AntiAim" then
            local antiaim_t = t * 22 * speed_multiplier
            local antiaim_scale = distance * 0.2
            x = antiaim_scale * math.sin(antiaim_t) * (0.5 + math.random() * 1.5)
            z = antiaim_scale * math.cos(antiaim_t) * (0.5 + math.random() * 1.5)
        elseif current_mode == "Pringle" then
            local pringle_t = t * 7 * speed_multiplier
            local pringle_scale = distance * 0.6
            x = pringle_scale * math.sin(pringle_t) * (1 + 0.5 * math.sin(pringle_t * 3.14159))
            z = pringle_scale * math.cos(pringle_t) * (1 + 0.5 * math.cos(pringle_t * 3.14159))
        elseif current_mode == "Random Spike" then
            local spike_t = t * 50 * speed_multiplier
            local spike_scale = distance * 0.5
            if math.random() < 0.15 then
                x = spike_scale * (math.random() - 0.5) * 4
                z = spike_scale * (math.random() - 0.5) * 4
            else
                x = spike_scale * math.sin(spike_t) * 0.3
                z = spike_scale * math.cos(spike_t) * 0.3
            end
        elseif current_mode == "Circle" then
            local circle_t = t * 5 * speed_multiplier
            local circle_scale = distance * 0.8
            x = circle_scale * math.sin(circle_t)
            z = circle_scale * math.cos(circle_t)
        elseif current_mode == "Figure8" then
            local figure8_t = t * 3 * speed_multiplier
            local figure8_scale = distance * 0.7
            x = figure8_scale * math.sin(figure8_t)
            z = figure8_scale * math.sin(figure8_t * 2) * 0.5
        elseif current_mode == "Gridshot" then
            local grid_t = t * 18 * speed_multiplier
            local grid_scale = distance * 0.3
            local grid_phase = math.floor(grid_t / (math.pi * 0.5)) % 4
            if grid_phase == 0 then
                x = grid_scale * math.sin(grid_t * 2)
                z = 0
            elseif grid_phase == 1 then
                x = 0
                z = grid_scale * math.cos(grid_t * 2)
            elseif grid_phase == 2 then
                x = -grid_scale * math.sin(grid_t * 2)
                z = 0
            else
                x = 0
                z = -grid_scale * math.cos(grid_t * 2)
            end
        elseif current_mode == "Spiral" then
            local spiral_t = t * 2 * speed_multiplier
            local spiral_scale = distance * 0.9
            local spiral_radius = spiral_scale * (spiral_t % (6 * math.pi)) / (6 * math.pi)
            x = spiral_radius * math.cos(spiral_t)
            z = spiral_radius * math.sin(spiral_t)
        elseif current_mode == "SideDash" then
            local dash_t = t * 20 * speed_multiplier
            local dash_scale = distance * 0.4
            local dash_phase = math.floor(dash_t / math.pi) % 2
            if dash_phase == 0 then
                x = dash_scale * math.sin(dash_t * 2)
                z = dash_scale * 0.1
            else
                x = dash_scale * 0.1
                z = dash_scale * math.cos(dash_t * 2)
            end
        elseif current_mode == "ZigZag" then
            local zigzag_t = t * 30 * speed_multiplier
            local zigzag_scale = distance * 0.5
            x = zigzag_scale * math.sin(zigzag_t)
            z = zigzag_scale * math.sin(zigzag_t * 3) * 0.3
        elseif current_mode == "PulseInOut" then
            local pulse_t = t * 8 * speed_multiplier
            local pulse_scale = distance * 0.6
            local pulse_radius = pulse_scale * (0.2 + 0.8 * math.sin(pulse_t * 1.8))
            x = pulse_radius * math.sin(pulse_t)
            z = pulse_radius * math.cos(pulse_t)
        elseif current_mode == "Anchors" then
            local anchor_t = t * 1.5 * speed_multiplier
            local anchor_scale = distance * 0.5
            x = anchor_scale * math.sin(anchor_t) * (1 + 0.6 * math.sin(anchor_t * 0.2))
            z = anchor_scale * math.cos(anchor_t) * (1 + 0.6 * math.cos(anchor_t * 0.2))
        elseif current_mode == "YoYo" then
            local yoyo_t = t * 16 * speed_multiplier
            local yoyo_scale = distance * 0.3
            local yoyo_radius = yoyo_scale * (0.1 + 0.9 * math.abs(math.sin(yoyo_t * 2)))
            x = yoyo_radius * math.sin(yoyo_t)
            z = yoyo_radius * math.cos(yoyo_t)
        elseif current_mode == "Pendulum" then
            local pendulum_t = t * 6 * speed_multiplier
            local pendulum_scale = distance * 0.8
            x = pendulum_scale * math.sin(pendulum_t)
            z = pendulum_scale * math.cos(pendulum_t) * 0.2
        elseif current_mode == "Void Strafe" then
            local void_strafe_t = t * 6 * speed_multiplier
            local void_strafe_scale = distance * 0.6
            x = void_strafe_scale * math.floor(math.sin(void_strafe_t * 2) * 2) / 2
            z = void_strafe_scale * math.floor(math.cos(void_strafe_t * 2) * 2) / 2
        elseif current_mode == "Adaptive Strafe" then
            local adaptive_strafe_t = t * 11 * speed_multiplier
            local adaptive_strafe_scale = distance * 0.5
            x = adaptive_strafe_scale * (math.sin(adaptive_strafe_t) + 0.4 * math.sin(adaptive_strafe_t * 3.14159))
            z = adaptive_strafe_scale * (math.cos(adaptive_strafe_t) + 0.4 * math.cos(adaptive_strafe_t * 3.14159))
        else
            local angle = (t * 10 * speed_multiplier) % (2 * math.pi)
            x = math.cos(angle) * (distance * 0.6)
            z = math.sin(angle) * (distance * 0.6)
        end
        
        if randomness > 0 then
            local random_factor = randomness / 2
            local random_x = (math.random() - 0.5) * distance * 0.15 * random_factor
            local random_z = (math.random() - 0.5) * distance * 0.15 * random_factor
            x = x + random_x
            z = z + random_z
        end
        
        local pos = center + Vector3.new(x, height, z)
        return CFrame.new(pos)
    end
    
    local function wrapper()
        local ok, res = xpcall(compute, function(e)
            return nil
        end)
        if ok then return res end
        return nil
    end
    getgenv().wanderkidd_current_strafe = wrapper
    
    local unsafe_mode = val(force_unsafe, false)
    local want_local_loop = unsafe_mode or not (api and api.ragebot_strafe_override)
    if api and api.ragebot_strafe_override and not unsafe_mode then
        api:ragebot_strafe_override(wrapper, unsafe_mode)
        if getgenv().wanderkidd_strafe_loop then
            pcall(function() getgenv().wanderkidd_strafe_loop:Disconnect() end)
            getgenv().wanderkidd_strafe_loop = nil
        end
    else
        if not getgenv().wanderkidd_strafe_loop then
            getgenv().wanderkidd_strafe_loop = RunService.Heartbeat:Connect(function()
                local fn = getgenv().wanderkidd_current_strafe
                if type(fn) == "function" then
                    local cf = fn()
                    if cf and val(enable, false) and not val(better_void_toggle, false) then
                        pcall(function()
                            set_desync_cframe(cf)
                        end)
                    end
                end
            end)
        end
    end
end

pcall(register)

-- Hit Sound System
local function createHitSound()
    local sound = Instance.new("Sound")
    sound.Parent = game.Players.LocalPlayer.Character.HumanoidRootPart
    local sound_id = val(input_sound_id, "8394333801")
    local volume = val(slider_volume, 50) / 100
    local speed = val(slider_sound_speed, 1.0)
    
    sound.SoundId = "rbxassetid://" .. sound_id
    sound.Volume = volume
    sound.PlaybackSpeed = speed

    sound:Play()

    sound.Ended:Connect(function()
        sound:Destroy()
    end)
end

local lastHealth = nil
local lastTarget = nil

game:GetService("RunService").Heartbeat:Connect(function(dt)
    if val(toggle_custom_hit_sound, true) then
        local target_cache = call_api("get_target_cache", "ragebot")
        
        if target_cache and target_cache.player and target_cache.player.Character and target_cache.player.Character:FindFirstChild("Humanoid") then
            local humanoid = target_cache.player.Character:FindFirstChild("Humanoid")
            
            if humanoid then
                local currentHealth = math.round(humanoid.Health)
                
                if lastHealth == nil or target_cache.player ~= lastTarget then
                    lastHealth = currentHealth
                end

                if currentHealth < lastHealth then
                    createHitSound()
                end

                lastHealth = currentHealth
                lastTarget = target_cache.player
            end
        end
    end
end)
